package localmachine

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Availability) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Day":
			z.Day, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Day")
				return
			}
		case "Week":
			z.Week, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Week")
				return
			}
		case "Month":
			z.Month, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Month")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Availability) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Day"
	err = en.Append(0x83, 0xa3, 0x44, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Day)
	if err != nil {
		err = msgp.WrapError(err, "Day")
		return
	}
	// write "Week"
	err = en.Append(0xa4, 0x57, 0x65, 0x65, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Week)
	if err != nil {
		err = msgp.WrapError(err, "Week")
		return
	}
	// write "Month"
	err = en.Append(0xa5, 0x4d, 0x6f, 0x6e, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Month)
	if err != nil {
		err = msgp.WrapError(err, "Month")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Availability) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Day"
	o = append(o, 0x83, 0xa3, 0x44, 0x61, 0x79)
	o = msgp.AppendUint64(o, z.Day)
	// string "Week"
	o = append(o, 0xa4, 0x57, 0x65, 0x65, 0x6b)
	o = msgp.AppendUint64(o, z.Week)
	// string "Month"
	o = append(o, 0xa5, 0x4d, 0x6f, 0x6e, 0x74, 0x68)
	o = msgp.AppendUint64(o, z.Month)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Availability) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Day":
			z.Day, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Day")
				return
			}
		case "Week":
			z.Week, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Week")
				return
			}
		case "Month":
			z.Month, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Month")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Availability) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 6 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Group) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		case "Comment":
			z.Comment, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Comment")
				return
			}
		case "Members":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([]Member, zb0002)
			}
			for za0001 := range z.Members {
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Members", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Members[za0001].Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Members", za0001, "Name")
							return
						}
					case "SID":
						z.Members[za0001].SID, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Members", za0001, "SID")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Members", za0001)
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Group) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Name"
	err = en.Append(0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "SID"
	err = en.Append(0xa3, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.SID)
	if err != nil {
		err = msgp.WrapError(err, "SID")
		return
	}
	// write "Comment"
	err = en.Append(0xa7, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Comment)
	if err != nil {
		err = msgp.WrapError(err, "Comment")
		return
	}
	// write "Members"
	err = en.Append(0xa7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Members)))
	if err != nil {
		err = msgp.WrapError(err, "Members")
		return
	}
	for za0001 := range z.Members {
		// map header, size 2
		// write "Name"
		err = en.Append(0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Members[za0001].Name)
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001, "Name")
			return
		}
		// write "SID"
		err = en.Append(0xa3, 0x53, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.Members[za0001].SID)
		if err != nil {
			err = msgp.WrapError(err, "Members", za0001, "SID")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Group) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Name"
	o = append(o, 0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "SID"
	o = append(o, 0xa3, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.SID)
	// string "Comment"
	o = append(o, 0xa7, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Comment)
	// string "Members"
	o = append(o, 0xa7, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Members)))
	for za0001 := range z.Members {
		// map header, size 2
		// string "Name"
		o = append(o, 0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Members[za0001].Name)
		// string "SID"
		o = append(o, 0xa3, 0x53, 0x49, 0x44)
		o = msgp.AppendString(o, z.Members[za0001].SID)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Group) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		case "Comment":
			z.Comment, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Comment")
				return
			}
		case "Members":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([]Member, zb0002)
			}
			for za0001 := range z.Members {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Members", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Members", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Members[za0001].Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Members", za0001, "Name")
							return
						}
					case "SID":
						z.Members[za0001].SID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Members", za0001, "SID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Members", za0001)
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Group) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 4 + msgp.StringPrefixSize + len(z.SID) + 8 + msgp.StringPrefixSize + len(z.Comment) + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Members {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Members[za0001].Name) + 4 + msgp.StringPrefixSize + len(z.Members[za0001].SID)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Groups) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Groups, zb0002)
	}
	for zb0001 := range *z {
		err = (*z)[zb0001].DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Groups) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		err = z[zb0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Groups) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0003 := range z {
		o, err = z[zb0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Groups) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Groups, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Groups) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		s += z[zb0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Info) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Common":
			err = z.Common.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Common")
				return
			}
		case "RegistryData":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "RegistryData")
				return
			}
			if z.RegistryData == nil {
				z.RegistryData = make(RegistryData, zb0002)
			} else if len(z.RegistryData) > 0 {
				for key := range z.RegistryData {
					delete(z.RegistryData, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RegistryData")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "RegistryData", za0001)
					return
				}
				z.RegistryData[za0001] = za0002
			}
		case "Machine":
			err = z.Machine.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Machine")
				return
			}
		case "LoginPopularity":
			err = z.LoginPopularity.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "LoginPopularity")
				return
			}
		case "Network":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Network")
					return
				}
				switch msgp.UnsafeString(field) {
				case "InternetConnectivity":
					z.Network.InternetConnectivity, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Network", "InternetConnectivity")
						return
					}
				case "NetworkInterfaces":
					var zb0004 uint32
					zb0004, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Network", "NetworkInterfaces")
						return
					}
					if cap(z.Network.NetworkInterfaces) >= int(zb0004) {
						z.Network.NetworkInterfaces = (z.Network.NetworkInterfaces)[:zb0004]
					} else {
						z.Network.NetworkInterfaces = make([]NetworkInterfaceInfo, zb0004)
					}
					for za0003 := range z.Network.NetworkInterfaces {
						err = z.Network.NetworkInterfaces[za0003].DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Network", "NetworkInterfaces", za0003)
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Network")
						return
					}
				}
			}
		case "Users":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0005) {
				z.Users = (z.Users)[:zb0005]
			} else {
				z.Users = make(Users, zb0005)
			}
			for za0004 := range z.Users {
				err = z.Users[za0004].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Users", za0004)
					return
				}
			}
		case "Groups":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Groups")
				return
			}
			if cap(z.Groups) >= int(zb0006) {
				z.Groups = (z.Groups)[:zb0006]
			} else {
				z.Groups = make(Groups, zb0006)
			}
			for za0005 := range z.Groups {
				err = z.Groups[za0005].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Groups", za0005)
					return
				}
			}
		case "Shares":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Shares")
				return
			}
			if cap(z.Shares) >= int(zb0007) {
				z.Shares = (z.Shares)[:zb0007]
			} else {
				z.Shares = make(Shares, zb0007)
			}
			for za0006 := range z.Shares {
				err = z.Shares[za0006].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Shares", za0006)
					return
				}
			}
		case "Services":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Services")
				return
			}
			if cap(z.Services) >= int(zb0008) {
				z.Services = (z.Services)[:zb0008]
			} else {
				z.Services = make(Services, zb0008)
			}
			for za0007 := range z.Services {
				err = z.Services[za0007].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Services", za0007)
					return
				}
			}
		case "Software":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Software")
				return
			}
			if cap(z.Software) >= int(zb0009) {
				z.Software = (z.Software)[:zb0009]
			} else {
				z.Software = make([]Software, zb0009)
			}
			for za0008 := range z.Software {
				err = z.Software[za0008].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Software", za0008)
					return
				}
			}
		case "Tasks":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Tasks")
				return
			}
			if cap(z.Tasks) >= int(zb0010) {
				z.Tasks = (z.Tasks)[:zb0010]
			} else {
				z.Tasks = make([]RegisteredTask, zb0010)
			}
			for za0009 := range z.Tasks {
				err = z.Tasks[za0009].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Tasks", za0009)
					return
				}
			}
		case "Privileges":
			err = z.Privileges.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Privileges")
				return
			}
		case "Availability":
			var zb0011 uint32
			zb0011, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Availability")
				return
			}
			for zb0011 > 0 {
				zb0011--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Availability")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Day":
					z.Availability.Day, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Availability", "Day")
						return
					}
				case "Week":
					z.Availability.Week, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Availability", "Week")
						return
					}
				case "Month":
					z.Availability.Month, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Availability", "Month")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Availability")
						return
					}
				}
			}
		case "UnprivilegedCollection":
			z.UnprivilegedCollection, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "UnprivilegedCollection")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Info) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "Common"
	err = en.Append(0x8e, 0xa6, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = z.Common.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Common")
		return
	}
	// write "RegistryData"
	err = en.Append(0xac, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.RegistryData)))
	if err != nil {
		err = msgp.WrapError(err, "RegistryData")
		return
	}
	for za0001, za0002 := range z.RegistryData {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "RegistryData")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "RegistryData", za0001)
			return
		}
	}
	// write "Machine"
	err = en.Append(0xa7, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = z.Machine.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Machine")
		return
	}
	// write "LoginPopularity"
	err = en.Append(0xaf, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x50, 0x6f, 0x70, 0x75, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = z.LoginPopularity.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "LoginPopularity")
		return
	}
	// write "Network"
	err = en.Append(0xa7, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b)
	if err != nil {
		return
	}
	// map header, size 2
	// write "InternetConnectivity"
	err = en.Append(0x82, 0xb4, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Network.InternetConnectivity)
	if err != nil {
		err = msgp.WrapError(err, "Network", "InternetConnectivity")
		return
	}
	// write "NetworkInterfaces"
	err = en.Append(0xb1, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Network.NetworkInterfaces)))
	if err != nil {
		err = msgp.WrapError(err, "Network", "NetworkInterfaces")
		return
	}
	for za0003 := range z.Network.NetworkInterfaces {
		err = z.Network.NetworkInterfaces[za0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Network", "NetworkInterfaces", za0003)
			return
		}
	}
	// write "Users"
	err = en.Append(0xa5, 0x55, 0x73, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Users)))
	if err != nil {
		err = msgp.WrapError(err, "Users")
		return
	}
	for za0004 := range z.Users {
		err = z.Users[za0004].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Users", za0004)
			return
		}
	}
	// write "Groups"
	err = en.Append(0xa6, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Groups)))
	if err != nil {
		err = msgp.WrapError(err, "Groups")
		return
	}
	for za0005 := range z.Groups {
		err = z.Groups[za0005].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Groups", za0005)
			return
		}
	}
	// write "Shares"
	err = en.Append(0xa6, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Shares)))
	if err != nil {
		err = msgp.WrapError(err, "Shares")
		return
	}
	for za0006 := range z.Shares {
		err = z.Shares[za0006].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Shares", za0006)
			return
		}
	}
	// write "Services"
	err = en.Append(0xa8, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Services)))
	if err != nil {
		err = msgp.WrapError(err, "Services")
		return
	}
	for za0007 := range z.Services {
		err = z.Services[za0007].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Services", za0007)
			return
		}
	}
	// write "Software"
	err = en.Append(0xa8, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Software)))
	if err != nil {
		err = msgp.WrapError(err, "Software")
		return
	}
	for za0008 := range z.Software {
		err = z.Software[za0008].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Software", za0008)
			return
		}
	}
	// write "Tasks"
	err = en.Append(0xa5, 0x54, 0x61, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Tasks)))
	if err != nil {
		err = msgp.WrapError(err, "Tasks")
		return
	}
	for za0009 := range z.Tasks {
		err = z.Tasks[za0009].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Tasks", za0009)
			return
		}
	}
	// write "Privileges"
	err = en.Append(0xaa, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = z.Privileges.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Privileges")
		return
	}
	// write "Availability"
	err = en.Append(0xac, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	// map header, size 3
	// write "Day"
	err = en.Append(0x83, 0xa3, 0x44, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Availability.Day)
	if err != nil {
		err = msgp.WrapError(err, "Availability", "Day")
		return
	}
	// write "Week"
	err = en.Append(0xa4, 0x57, 0x65, 0x65, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Availability.Week)
	if err != nil {
		err = msgp.WrapError(err, "Availability", "Week")
		return
	}
	// write "Month"
	err = en.Append(0xa5, 0x4d, 0x6f, 0x6e, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Availability.Month)
	if err != nil {
		err = msgp.WrapError(err, "Availability", "Month")
		return
	}
	// write "UnprivilegedCollection"
	err = en.Append(0xb6, 0x55, 0x6e, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.UnprivilegedCollection)
	if err != nil {
		err = msgp.WrapError(err, "UnprivilegedCollection")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Info) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "Common"
	o = append(o, 0x8e, 0xa6, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
	o, err = z.Common.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Common")
		return
	}
	// string "RegistryData"
	o = append(o, 0xac, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendMapHeader(o, uint32(len(z.RegistryData)))
	for za0001, za0002 := range z.RegistryData {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "RegistryData", za0001)
			return
		}
	}
	// string "Machine"
	o = append(o, 0xa7, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65)
	o, err = z.Machine.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Machine")
		return
	}
	// string "LoginPopularity"
	o = append(o, 0xaf, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x50, 0x6f, 0x70, 0x75, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79)
	o, err = z.LoginPopularity.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "LoginPopularity")
		return
	}
	// string "Network"
	o = append(o, 0xa7, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b)
	// map header, size 2
	// string "InternetConnectivity"
	o = append(o, 0x82, 0xb4, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79)
	o = msgp.AppendString(o, z.Network.InternetConnectivity)
	// string "NetworkInterfaces"
	o = append(o, 0xb1, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Network.NetworkInterfaces)))
	for za0003 := range z.Network.NetworkInterfaces {
		o, err = z.Network.NetworkInterfaces[za0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Network", "NetworkInterfaces", za0003)
			return
		}
	}
	// string "Users"
	o = append(o, 0xa5, 0x55, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0004 := range z.Users {
		o, err = z.Users[za0004].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Users", za0004)
			return
		}
	}
	// string "Groups"
	o = append(o, 0xa6, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Groups)))
	for za0005 := range z.Groups {
		o, err = z.Groups[za0005].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Groups", za0005)
			return
		}
	}
	// string "Shares"
	o = append(o, 0xa6, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Shares)))
	for za0006 := range z.Shares {
		o, err = z.Shares[za0006].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Shares", za0006)
			return
		}
	}
	// string "Services"
	o = append(o, 0xa8, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Services)))
	for za0007 := range z.Services {
		o, err = z.Services[za0007].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Services", za0007)
			return
		}
	}
	// string "Software"
	o = append(o, 0xa8, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Software)))
	for za0008 := range z.Software {
		o, err = z.Software[za0008].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Software", za0008)
			return
		}
	}
	// string "Tasks"
	o = append(o, 0xa5, 0x54, 0x61, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Tasks)))
	for za0009 := range z.Tasks {
		o, err = z.Tasks[za0009].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Tasks", za0009)
			return
		}
	}
	// string "Privileges"
	o = append(o, 0xaa, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x73)
	o, err = z.Privileges.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Privileges")
		return
	}
	// string "Availability"
	o = append(o, 0xac, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
	// map header, size 3
	// string "Day"
	o = append(o, 0x83, 0xa3, 0x44, 0x61, 0x79)
	o = msgp.AppendUint64(o, z.Availability.Day)
	// string "Week"
	o = append(o, 0xa4, 0x57, 0x65, 0x65, 0x6b)
	o = msgp.AppendUint64(o, z.Availability.Week)
	// string "Month"
	o = append(o, 0xa5, 0x4d, 0x6f, 0x6e, 0x74, 0x68)
	o = msgp.AppendUint64(o, z.Availability.Month)
	// string "UnprivilegedCollection"
	o = append(o, 0xb6, 0x55, 0x6e, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendBool(o, z.UnprivilegedCollection)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Info) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Common":
			bts, err = z.Common.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Common")
				return
			}
		case "RegistryData":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RegistryData")
				return
			}
			if z.RegistryData == nil {
				z.RegistryData = make(RegistryData, zb0002)
			} else if len(z.RegistryData) > 0 {
				for key := range z.RegistryData {
					delete(z.RegistryData, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RegistryData")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RegistryData", za0001)
					return
				}
				z.RegistryData[za0001] = za0002
			}
		case "Machine":
			bts, err = z.Machine.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Machine")
				return
			}
		case "LoginPopularity":
			bts, err = z.LoginPopularity.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "LoginPopularity")
				return
			}
		case "Network":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Network")
					return
				}
				switch msgp.UnsafeString(field) {
				case "InternetConnectivity":
					z.Network.InternetConnectivity, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Network", "InternetConnectivity")
						return
					}
				case "NetworkInterfaces":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Network", "NetworkInterfaces")
						return
					}
					if cap(z.Network.NetworkInterfaces) >= int(zb0004) {
						z.Network.NetworkInterfaces = (z.Network.NetworkInterfaces)[:zb0004]
					} else {
						z.Network.NetworkInterfaces = make([]NetworkInterfaceInfo, zb0004)
					}
					for za0003 := range z.Network.NetworkInterfaces {
						bts, err = z.Network.NetworkInterfaces[za0003].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Network", "NetworkInterfaces", za0003)
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Network")
						return
					}
				}
			}
		case "Users":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0005) {
				z.Users = (z.Users)[:zb0005]
			} else {
				z.Users = make(Users, zb0005)
			}
			for za0004 := range z.Users {
				bts, err = z.Users[za0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Users", za0004)
					return
				}
			}
		case "Groups":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Groups")
				return
			}
			if cap(z.Groups) >= int(zb0006) {
				z.Groups = (z.Groups)[:zb0006]
			} else {
				z.Groups = make(Groups, zb0006)
			}
			for za0005 := range z.Groups {
				bts, err = z.Groups[za0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Groups", za0005)
					return
				}
			}
		case "Shares":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Shares")
				return
			}
			if cap(z.Shares) >= int(zb0007) {
				z.Shares = (z.Shares)[:zb0007]
			} else {
				z.Shares = make(Shares, zb0007)
			}
			for za0006 := range z.Shares {
				bts, err = z.Shares[za0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Shares", za0006)
					return
				}
			}
		case "Services":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Services")
				return
			}
			if cap(z.Services) >= int(zb0008) {
				z.Services = (z.Services)[:zb0008]
			} else {
				z.Services = make(Services, zb0008)
			}
			for za0007 := range z.Services {
				bts, err = z.Services[za0007].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Services", za0007)
					return
				}
			}
		case "Software":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Software")
				return
			}
			if cap(z.Software) >= int(zb0009) {
				z.Software = (z.Software)[:zb0009]
			} else {
				z.Software = make([]Software, zb0009)
			}
			for za0008 := range z.Software {
				bts, err = z.Software[za0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Software", za0008)
					return
				}
			}
		case "Tasks":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tasks")
				return
			}
			if cap(z.Tasks) >= int(zb0010) {
				z.Tasks = (z.Tasks)[:zb0010]
			} else {
				z.Tasks = make([]RegisteredTask, zb0010)
			}
			for za0009 := range z.Tasks {
				bts, err = z.Tasks[za0009].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tasks", za0009)
					return
				}
			}
		case "Privileges":
			bts, err = z.Privileges.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Privileges")
				return
			}
		case "Availability":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Availability")
				return
			}
			for zb0011 > 0 {
				zb0011--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Availability")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Day":
					z.Availability.Day, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Availability", "Day")
						return
					}
				case "Week":
					z.Availability.Week, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Availability", "Week")
						return
					}
				case "Month":
					z.Availability.Month, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Availability", "Month")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Availability")
						return
					}
				}
			}
		case "UnprivilegedCollection":
			z.UnprivilegedCollection, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UnprivilegedCollection")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Info) Msgsize() (s int) {
	s = 1 + 7 + z.Common.Msgsize() + 13 + msgp.MapHeaderSize
	if z.RegistryData != nil {
		for za0001, za0002 := range z.RegistryData {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	s += 8 + z.Machine.Msgsize() + 16 + z.LoginPopularity.Msgsize() + 8 + 1 + 21 + msgp.StringPrefixSize + len(z.Network.InternetConnectivity) + 18 + msgp.ArrayHeaderSize
	for za0003 := range z.Network.NetworkInterfaces {
		s += z.Network.NetworkInterfaces[za0003].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0004 := range z.Users {
		s += z.Users[za0004].Msgsize()
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0005 := range z.Groups {
		s += z.Groups[za0005].Msgsize()
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0006 := range z.Shares {
		s += z.Shares[za0006].Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0007 := range z.Services {
		s += z.Services[za0007].Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0008 := range z.Software {
		s += z.Software[za0008].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0009 := range z.Tasks {
		s += z.Tasks[za0009].Msgsize()
	}
	s += 11 + z.Privileges.Msgsize() + 13 + 1 + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 6 + msgp.Uint64Size + 23 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginCount) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		case "Count":
			z.Count, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z LoginCount) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Name"
	err = en.Append(0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "SID"
	err = en.Append(0xa3, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.SID)
	if err != nil {
		err = msgp.WrapError(err, "SID")
		return
	}
	// write "Count"
	err = en.Append(0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LoginCount) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Name"
	o = append(o, 0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "SID"
	o = append(o, 0xa3, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.SID)
	// string "Count"
	o = append(o, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.Count)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginCount) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		case "Count":
			z.Count, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LoginCount) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 4 + msgp.StringPrefixSize + len(z.SID) + 6 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginPopularity) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Day":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Day")
				return
			}
			if cap(z.Day) >= int(zb0002) {
				z.Day = (z.Day)[:zb0002]
			} else {
				z.Day = make([]LoginCount, zb0002)
			}
			for za0001 := range z.Day {
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Day", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Day", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Day[za0001].Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001, "Name")
							return
						}
					case "SID":
						z.Day[za0001].SID, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001, "SID")
							return
						}
					case "Count":
						z.Day[za0001].Count, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001, "Count")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001)
							return
						}
					}
				}
			}
		case "Week":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Week")
				return
			}
			if cap(z.Week) >= int(zb0004) {
				z.Week = (z.Week)[:zb0004]
			} else {
				z.Week = make([]LoginCount, zb0004)
			}
			for za0002 := range z.Week {
				var zb0005 uint32
				zb0005, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Week", za0002)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Week", za0002)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Week[za0002].Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002, "Name")
							return
						}
					case "SID":
						z.Week[za0002].SID, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002, "SID")
							return
						}
					case "Count":
						z.Week[za0002].Count, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002, "Count")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002)
							return
						}
					}
				}
			}
		case "Month":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Month")
				return
			}
			if cap(z.Month) >= int(zb0006) {
				z.Month = (z.Month)[:zb0006]
			} else {
				z.Month = make([]LoginCount, zb0006)
			}
			for za0003 := range z.Month {
				var zb0007 uint32
				zb0007, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Month", za0003)
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Month", za0003)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Month[za0003].Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003, "Name")
							return
						}
					case "SID":
						z.Month[za0003].SID, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003, "SID")
							return
						}
					case "Count":
						z.Month[za0003].Count, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003, "Count")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003)
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LoginPopularity) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Day"
	err = en.Append(0x83, 0xa3, 0x44, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Day)))
	if err != nil {
		err = msgp.WrapError(err, "Day")
		return
	}
	for za0001 := range z.Day {
		// map header, size 3
		// write "Name"
		err = en.Append(0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Day[za0001].Name)
		if err != nil {
			err = msgp.WrapError(err, "Day", za0001, "Name")
			return
		}
		// write "SID"
		err = en.Append(0xa3, 0x53, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.Day[za0001].SID)
		if err != nil {
			err = msgp.WrapError(err, "Day", za0001, "SID")
			return
		}
		// write "Count"
		err = en.Append(0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Day[za0001].Count)
		if err != nil {
			err = msgp.WrapError(err, "Day", za0001, "Count")
			return
		}
	}
	// write "Week"
	err = en.Append(0xa4, 0x57, 0x65, 0x65, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Week)))
	if err != nil {
		err = msgp.WrapError(err, "Week")
		return
	}
	for za0002 := range z.Week {
		// map header, size 3
		// write "Name"
		err = en.Append(0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Week[za0002].Name)
		if err != nil {
			err = msgp.WrapError(err, "Week", za0002, "Name")
			return
		}
		// write "SID"
		err = en.Append(0xa3, 0x53, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.Week[za0002].SID)
		if err != nil {
			err = msgp.WrapError(err, "Week", za0002, "SID")
			return
		}
		// write "Count"
		err = en.Append(0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Week[za0002].Count)
		if err != nil {
			err = msgp.WrapError(err, "Week", za0002, "Count")
			return
		}
	}
	// write "Month"
	err = en.Append(0xa5, 0x4d, 0x6f, 0x6e, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Month)))
	if err != nil {
		err = msgp.WrapError(err, "Month")
		return
	}
	for za0003 := range z.Month {
		// map header, size 3
		// write "Name"
		err = en.Append(0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Month[za0003].Name)
		if err != nil {
			err = msgp.WrapError(err, "Month", za0003, "Name")
			return
		}
		// write "SID"
		err = en.Append(0xa3, 0x53, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.Month[za0003].SID)
		if err != nil {
			err = msgp.WrapError(err, "Month", za0003, "SID")
			return
		}
		// write "Count"
		err = en.Append(0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Month[za0003].Count)
		if err != nil {
			err = msgp.WrapError(err, "Month", za0003, "Count")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LoginPopularity) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Day"
	o = append(o, 0x83, 0xa3, 0x44, 0x61, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Day)))
	for za0001 := range z.Day {
		// map header, size 3
		// string "Name"
		o = append(o, 0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Day[za0001].Name)
		// string "SID"
		o = append(o, 0xa3, 0x53, 0x49, 0x44)
		o = msgp.AppendString(o, z.Day[za0001].SID)
		// string "Count"
		o = append(o, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.Day[za0001].Count)
	}
	// string "Week"
	o = append(o, 0xa4, 0x57, 0x65, 0x65, 0x6b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Week)))
	for za0002 := range z.Week {
		// map header, size 3
		// string "Name"
		o = append(o, 0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Week[za0002].Name)
		// string "SID"
		o = append(o, 0xa3, 0x53, 0x49, 0x44)
		o = msgp.AppendString(o, z.Week[za0002].SID)
		// string "Count"
		o = append(o, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.Week[za0002].Count)
	}
	// string "Month"
	o = append(o, 0xa5, 0x4d, 0x6f, 0x6e, 0x74, 0x68)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Month)))
	for za0003 := range z.Month {
		// map header, size 3
		// string "Name"
		o = append(o, 0x83, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Month[za0003].Name)
		// string "SID"
		o = append(o, 0xa3, 0x53, 0x49, 0x44)
		o = msgp.AppendString(o, z.Month[za0003].SID)
		// string "Count"
		o = append(o, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.Month[za0003].Count)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginPopularity) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Day":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Day")
				return
			}
			if cap(z.Day) >= int(zb0002) {
				z.Day = (z.Day)[:zb0002]
			} else {
				z.Day = make([]LoginCount, zb0002)
			}
			for za0001 := range z.Day {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Day", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Day", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Day[za0001].Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001, "Name")
							return
						}
					case "SID":
						z.Day[za0001].SID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001, "SID")
							return
						}
					case "Count":
						z.Day[za0001].Count, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001, "Count")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Day", za0001)
							return
						}
					}
				}
			}
		case "Week":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Week")
				return
			}
			if cap(z.Week) >= int(zb0004) {
				z.Week = (z.Week)[:zb0004]
			} else {
				z.Week = make([]LoginCount, zb0004)
			}
			for za0002 := range z.Week {
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Week", za0002)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Week", za0002)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Week[za0002].Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002, "Name")
							return
						}
					case "SID":
						z.Week[za0002].SID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002, "SID")
							return
						}
					case "Count":
						z.Week[za0002].Count, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002, "Count")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Week", za0002)
							return
						}
					}
				}
			}
		case "Month":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Month")
				return
			}
			if cap(z.Month) >= int(zb0006) {
				z.Month = (z.Month)[:zb0006]
			} else {
				z.Month = make([]LoginCount, zb0006)
			}
			for za0003 := range z.Month {
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Month", za0003)
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Month", za0003)
						return
					}
					switch msgp.UnsafeString(field) {
					case "Name":
						z.Month[za0003].Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003, "Name")
							return
						}
					case "SID":
						z.Month[za0003].SID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003, "SID")
							return
						}
					case "Count":
						z.Month[za0003].Count, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003, "Count")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Month", za0003)
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LoginPopularity) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.Day {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Day[za0001].Name) + 4 + msgp.StringPrefixSize + len(z.Day[za0001].SID) + 6 + msgp.Uint64Size
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0002 := range z.Week {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Week[za0002].Name) + 4 + msgp.StringPrefixSize + len(z.Week[za0002].SID) + 6 + msgp.Uint64Size
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0003 := range z.Month {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Month[za0003].Name) + 4 + msgp.StringPrefixSize + len(z.Month[za0003].SID) + 6 + msgp.Uint64Size
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Machine) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "LocalSID":
			z.LocalSID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LocalSID")
				return
			}
		case "Domain":
			z.Domain, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Domain")
				return
			}
		case "ComputerDomainSID":
			z.ComputerDomainSID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ComputerDomainSID")
				return
			}
		case "Architecture":
			z.Architecture, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Architecture")
				return
			}
		case "ProductName":
			z.ProductName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductName")
				return
			}
		case "ProductType":
			z.ProductType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductType")
				return
			}
		case "ProductSuite":
			z.ProductSuite, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductSuite")
				return
			}
		case "EditionID":
			z.EditionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EditionID")
				return
			}
		case "ReleaseID":
			z.ReleaseID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ReleaseID")
				return
			}
		case "BuildBranch":
			z.BuildBranch, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BuildBranch")
				return
			}
		case "Version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "BuildNumber":
			z.BuildNumber, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BuildNumber")
				return
			}
		case "DefaultUsername":
			z.DefaultUsername, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DefaultUsername")
				return
			}
		case "DefaultDomain":
			z.DefaultDomain, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DefaultDomain")
				return
			}
		case "AltDefaultUsername":
			z.AltDefaultUsername, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AltDefaultUsername")
				return
			}
		case "AltDefaultDomain":
			z.AltDefaultDomain, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AltDefaultDomain")
				return
			}
		case "SCCMLastValidMP":
			z.SCCMLastValidMP, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SCCMLastValidMP")
				return
			}
		case "WUServer":
			z.WUServer, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WUServer")
				return
			}
		case "WUStatusServer":
			z.WUStatusServer, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WUStatusServer")
				return
			}
		case "AppCache":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AppCache")
				return
			}
			if cap(z.AppCache) >= int(zb0002) {
				z.AppCache = (z.AppCache)[:zb0002]
			} else {
				z.AppCache = make([][]byte, zb0002)
			}
			for za0001 := range z.AppCache {
				z.AppCache[za0001], err = dc.ReadBytes(z.AppCache[za0001])
				if err != nil {
					err = msgp.WrapError(err, "AppCache", za0001)
					return
				}
			}
		case "NumberOfProcessors":
			z.NumberOfProcessors, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NumberOfProcessors")
				return
			}
		case "MajorVersionNumber":
			z.MajorVersionNumber, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MajorVersionNumber")
				return
			}
		case "IsDomainJoined":
			z.IsDomainJoined, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsDomainJoined")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Machine) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 24
	// write "Name"
	err = en.Append(0xde, 0x0, 0x18, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "LocalSID"
	err = en.Append(0xa8, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.LocalSID)
	if err != nil {
		err = msgp.WrapError(err, "LocalSID")
		return
	}
	// write "Domain"
	err = en.Append(0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Domain)
	if err != nil {
		err = msgp.WrapError(err, "Domain")
		return
	}
	// write "ComputerDomainSID"
	err = en.Append(0xb1, 0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ComputerDomainSID)
	if err != nil {
		err = msgp.WrapError(err, "ComputerDomainSID")
		return
	}
	// write "Architecture"
	err = en.Append(0xac, 0x41, 0x72, 0x63, 0x68, 0x69, 0x74, 0x65, 0x63, 0x74, 0x75, 0x72, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Architecture)
	if err != nil {
		err = msgp.WrapError(err, "Architecture")
		return
	}
	// write "ProductName"
	err = en.Append(0xab, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductName)
	if err != nil {
		err = msgp.WrapError(err, "ProductName")
		return
	}
	// write "ProductType"
	err = en.Append(0xab, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductType)
	if err != nil {
		err = msgp.WrapError(err, "ProductType")
		return
	}
	// write "ProductSuite"
	err = en.Append(0xac, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x53, 0x75, 0x69, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductSuite)
	if err != nil {
		err = msgp.WrapError(err, "ProductSuite")
		return
	}
	// write "EditionID"
	err = en.Append(0xa9, 0x45, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.EditionID)
	if err != nil {
		err = msgp.WrapError(err, "EditionID")
		return
	}
	// write "ReleaseID"
	err = en.Append(0xa9, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ReleaseID)
	if err != nil {
		err = msgp.WrapError(err, "ReleaseID")
		return
	}
	// write "BuildBranch"
	err = en.Append(0xab, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x42, 0x72, 0x61, 0x6e, 0x63, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.BuildBranch)
	if err != nil {
		err = msgp.WrapError(err, "BuildBranch")
		return
	}
	// write "Version"
	err = en.Append(0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "BuildNumber"
	err = en.Append(0xab, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.BuildNumber)
	if err != nil {
		err = msgp.WrapError(err, "BuildNumber")
		return
	}
	// write "DefaultUsername"
	err = en.Append(0xaf, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.DefaultUsername)
	if err != nil {
		err = msgp.WrapError(err, "DefaultUsername")
		return
	}
	// write "DefaultDomain"
	err = en.Append(0xad, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.DefaultDomain)
	if err != nil {
		err = msgp.WrapError(err, "DefaultDomain")
		return
	}
	// write "AltDefaultUsername"
	err = en.Append(0xb2, 0x41, 0x6c, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.AltDefaultUsername)
	if err != nil {
		err = msgp.WrapError(err, "AltDefaultUsername")
		return
	}
	// write "AltDefaultDomain"
	err = en.Append(0xb0, 0x41, 0x6c, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.AltDefaultDomain)
	if err != nil {
		err = msgp.WrapError(err, "AltDefaultDomain")
		return
	}
	// write "SCCMLastValidMP"
	err = en.Append(0xaf, 0x53, 0x43, 0x43, 0x4d, 0x4c, 0x61, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x4d, 0x50)
	if err != nil {
		return
	}
	err = en.WriteString(z.SCCMLastValidMP)
	if err != nil {
		err = msgp.WrapError(err, "SCCMLastValidMP")
		return
	}
	// write "WUServer"
	err = en.Append(0xa8, 0x57, 0x55, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.WUServer)
	if err != nil {
		err = msgp.WrapError(err, "WUServer")
		return
	}
	// write "WUStatusServer"
	err = en.Append(0xae, 0x57, 0x55, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.WUStatusServer)
	if err != nil {
		err = msgp.WrapError(err, "WUStatusServer")
		return
	}
	// write "AppCache"
	err = en.Append(0xa8, 0x41, 0x70, 0x70, 0x43, 0x61, 0x63, 0x68, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AppCache)))
	if err != nil {
		err = msgp.WrapError(err, "AppCache")
		return
	}
	for za0001 := range z.AppCache {
		err = en.WriteBytes(z.AppCache[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AppCache", za0001)
			return
		}
	}
	// write "NumberOfProcessors"
	err = en.Append(0xb2, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f, 0x66, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.NumberOfProcessors)
	if err != nil {
		err = msgp.WrapError(err, "NumberOfProcessors")
		return
	}
	// write "MajorVersionNumber"
	err = en.Append(0xb2, 0x4d, 0x61, 0x6a, 0x6f, 0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.MajorVersionNumber)
	if err != nil {
		err = msgp.WrapError(err, "MajorVersionNumber")
		return
	}
	// write "IsDomainJoined"
	err = en.Append(0xae, 0x49, 0x73, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x4a, 0x6f, 0x69, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsDomainJoined)
	if err != nil {
		err = msgp.WrapError(err, "IsDomainJoined")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Machine) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 24
	// string "Name"
	o = append(o, 0xde, 0x0, 0x18, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "LocalSID"
	o = append(o, 0xa8, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.LocalSID)
	// string "Domain"
	o = append(o, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	o = msgp.AppendString(o, z.Domain)
	// string "ComputerDomainSID"
	o = append(o, 0xb1, 0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.ComputerDomainSID)
	// string "Architecture"
	o = append(o, 0xac, 0x41, 0x72, 0x63, 0x68, 0x69, 0x74, 0x65, 0x63, 0x74, 0x75, 0x72, 0x65)
	o = msgp.AppendString(o, z.Architecture)
	// string "ProductName"
	o = append(o, 0xab, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ProductName)
	// string "ProductType"
	o = append(o, 0xab, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.ProductType)
	// string "ProductSuite"
	o = append(o, 0xac, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x53, 0x75, 0x69, 0x74, 0x65)
	o = msgp.AppendString(o, z.ProductSuite)
	// string "EditionID"
	o = append(o, 0xa9, 0x45, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.EditionID)
	// string "ReleaseID"
	o = append(o, 0xa9, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x49, 0x44)
	o = msgp.AppendString(o, z.ReleaseID)
	// string "BuildBranch"
	o = append(o, 0xab, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x42, 0x72, 0x61, 0x6e, 0x63, 0x68)
	o = msgp.AppendString(o, z.BuildBranch)
	// string "Version"
	o = append(o, 0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Version)
	// string "BuildNumber"
	o = append(o, 0xab, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.BuildNumber)
	// string "DefaultUsername"
	o = append(o, 0xaf, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.DefaultUsername)
	// string "DefaultDomain"
	o = append(o, 0xad, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	o = msgp.AppendString(o, z.DefaultDomain)
	// string "AltDefaultUsername"
	o = append(o, 0xb2, 0x41, 0x6c, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.AltDefaultUsername)
	// string "AltDefaultDomain"
	o = append(o, 0xb0, 0x41, 0x6c, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	o = msgp.AppendString(o, z.AltDefaultDomain)
	// string "SCCMLastValidMP"
	o = append(o, 0xaf, 0x53, 0x43, 0x43, 0x4d, 0x4c, 0x61, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x4d, 0x50)
	o = msgp.AppendString(o, z.SCCMLastValidMP)
	// string "WUServer"
	o = append(o, 0xa8, 0x57, 0x55, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.WUServer)
	// string "WUStatusServer"
	o = append(o, 0xae, 0x57, 0x55, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.WUStatusServer)
	// string "AppCache"
	o = append(o, 0xa8, 0x41, 0x70, 0x70, 0x43, 0x61, 0x63, 0x68, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AppCache)))
	for za0001 := range z.AppCache {
		o = msgp.AppendBytes(o, z.AppCache[za0001])
	}
	// string "NumberOfProcessors"
	o = append(o, 0xb2, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f, 0x66, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x6f, 0x72, 0x73)
	o = msgp.AppendInt(o, z.NumberOfProcessors)
	// string "MajorVersionNumber"
	o = append(o, 0xb2, 0x4d, 0x61, 0x6a, 0x6f, 0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendUint64(o, z.MajorVersionNumber)
	// string "IsDomainJoined"
	o = append(o, 0xae, 0x49, 0x73, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x4a, 0x6f, 0x69, 0x6e, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsDomainJoined)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Machine) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "LocalSID":
			z.LocalSID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LocalSID")
				return
			}
		case "Domain":
			z.Domain, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Domain")
				return
			}
		case "ComputerDomainSID":
			z.ComputerDomainSID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ComputerDomainSID")
				return
			}
		case "Architecture":
			z.Architecture, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Architecture")
				return
			}
		case "ProductName":
			z.ProductName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductName")
				return
			}
		case "ProductType":
			z.ProductType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductType")
				return
			}
		case "ProductSuite":
			z.ProductSuite, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductSuite")
				return
			}
		case "EditionID":
			z.EditionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EditionID")
				return
			}
		case "ReleaseID":
			z.ReleaseID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReleaseID")
				return
			}
		case "BuildBranch":
			z.BuildBranch, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuildBranch")
				return
			}
		case "Version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "BuildNumber":
			z.BuildNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuildNumber")
				return
			}
		case "DefaultUsername":
			z.DefaultUsername, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DefaultUsername")
				return
			}
		case "DefaultDomain":
			z.DefaultDomain, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DefaultDomain")
				return
			}
		case "AltDefaultUsername":
			z.AltDefaultUsername, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AltDefaultUsername")
				return
			}
		case "AltDefaultDomain":
			z.AltDefaultDomain, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AltDefaultDomain")
				return
			}
		case "SCCMLastValidMP":
			z.SCCMLastValidMP, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SCCMLastValidMP")
				return
			}
		case "WUServer":
			z.WUServer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WUServer")
				return
			}
		case "WUStatusServer":
			z.WUStatusServer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WUStatusServer")
				return
			}
		case "AppCache":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AppCache")
				return
			}
			if cap(z.AppCache) >= int(zb0002) {
				z.AppCache = (z.AppCache)[:zb0002]
			} else {
				z.AppCache = make([][]byte, zb0002)
			}
			for za0001 := range z.AppCache {
				z.AppCache[za0001], bts, err = msgp.ReadBytesBytes(bts, z.AppCache[za0001])
				if err != nil {
					err = msgp.WrapError(err, "AppCache", za0001)
					return
				}
			}
		case "NumberOfProcessors":
			z.NumberOfProcessors, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumberOfProcessors")
				return
			}
		case "MajorVersionNumber":
			z.MajorVersionNumber, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MajorVersionNumber")
				return
			}
		case "IsDomainJoined":
			z.IsDomainJoined, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsDomainJoined")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Machine) Msgsize() (s int) {
	s = 3 + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.StringPrefixSize + len(z.LocalSID) + 7 + msgp.StringPrefixSize + len(z.Domain) + 18 + msgp.StringPrefixSize + len(z.ComputerDomainSID) + 13 + msgp.StringPrefixSize + len(z.Architecture) + 12 + msgp.StringPrefixSize + len(z.ProductName) + 12 + msgp.StringPrefixSize + len(z.ProductType) + 13 + msgp.StringPrefixSize + len(z.ProductSuite) + 10 + msgp.StringPrefixSize + len(z.EditionID) + 10 + msgp.StringPrefixSize + len(z.ReleaseID) + 12 + msgp.StringPrefixSize + len(z.BuildBranch) + 8 + msgp.StringPrefixSize + len(z.Version) + 12 + msgp.StringPrefixSize + len(z.BuildNumber) + 16 + msgp.StringPrefixSize + len(z.DefaultUsername) + 14 + msgp.StringPrefixSize + len(z.DefaultDomain) + 19 + msgp.StringPrefixSize + len(z.AltDefaultUsername) + 17 + msgp.StringPrefixSize + len(z.AltDefaultDomain) + 16 + msgp.StringPrefixSize + len(z.SCCMLastValidMP) + 9 + msgp.StringPrefixSize + len(z.WUServer) + 15 + msgp.StringPrefixSize + len(z.WUStatusServer) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.AppCache {
		s += msgp.BytesPrefixSize + len(z.AppCache[za0001])
	}
	s += 19 + msgp.IntSize + 19 + msgp.Uint64Size + 15 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Member) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Member) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Name"
	err = en.Append(0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "SID"
	err = en.Append(0xa3, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.SID)
	if err != nil {
		err = msgp.WrapError(err, "SID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Member) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Name"
	o = append(o, 0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "SID"
	o = append(o, 0xa3, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.SID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Member) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Member) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 4 + msgp.StringPrefixSize + len(z.SID)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NetworkInformation) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "InternetConnectivity":
			z.InternetConnectivity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InternetConnectivity")
				return
			}
		case "NetworkInterfaces":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "NetworkInterfaces")
				return
			}
			if cap(z.NetworkInterfaces) >= int(zb0002) {
				z.NetworkInterfaces = (z.NetworkInterfaces)[:zb0002]
			} else {
				z.NetworkInterfaces = make([]NetworkInterfaceInfo, zb0002)
			}
			for za0001 := range z.NetworkInterfaces {
				err = z.NetworkInterfaces[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "NetworkInterfaces", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NetworkInformation) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "InternetConnectivity"
	err = en.Append(0x82, 0xb4, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.InternetConnectivity)
	if err != nil {
		err = msgp.WrapError(err, "InternetConnectivity")
		return
	}
	// write "NetworkInterfaces"
	err = en.Append(0xb1, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.NetworkInterfaces)))
	if err != nil {
		err = msgp.WrapError(err, "NetworkInterfaces")
		return
	}
	for za0001 := range z.NetworkInterfaces {
		err = z.NetworkInterfaces[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "NetworkInterfaces", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *NetworkInformation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "InternetConnectivity"
	o = append(o, 0x82, 0xb4, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79)
	o = msgp.AppendString(o, z.InternetConnectivity)
	// string "NetworkInterfaces"
	o = append(o, 0xb1, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.NetworkInterfaces)))
	for za0001 := range z.NetworkInterfaces {
		o, err = z.NetworkInterfaces[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "NetworkInterfaces", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NetworkInformation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "InternetConnectivity":
			z.InternetConnectivity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InternetConnectivity")
				return
			}
		case "NetworkInterfaces":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetworkInterfaces")
				return
			}
			if cap(z.NetworkInterfaces) >= int(zb0002) {
				z.NetworkInterfaces = (z.NetworkInterfaces)[:zb0002]
			} else {
				z.NetworkInterfaces = make([]NetworkInterfaceInfo, zb0002)
			}
			for za0001 := range z.NetworkInterfaces {
				bts, err = z.NetworkInterfaces[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NetworkInterfaces", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NetworkInformation) Msgsize() (s int) {
	s = 1 + 21 + msgp.StringPrefixSize + len(z.InternetConnectivity) + 18 + msgp.ArrayHeaderSize
	for za0001 := range z.NetworkInterfaces {
		s += z.NetworkInterfaces[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NetworkInterfaceInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "MACAddress":
			z.MACAddress, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MACAddress")
				return
			}
		case "Addresses":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Addresses")
				return
			}
			if cap(z.Addresses) >= int(zb0002) {
				z.Addresses = (z.Addresses)[:zb0002]
			} else {
				z.Addresses = make([]string, zb0002)
			}
			for za0001 := range z.Addresses {
				z.Addresses[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Addresses", za0001)
					return
				}
			}
		case "Flags":
			z.Flags, err = dc.ReadUint()
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NetworkInterfaceInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Name"
	err = en.Append(0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "MACAddress"
	err = en.Append(0xaa, 0x4d, 0x41, 0x43, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.MACAddress)
	if err != nil {
		err = msgp.WrapError(err, "MACAddress")
		return
	}
	// write "Addresses"
	err = en.Append(0xa9, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Addresses)))
	if err != nil {
		err = msgp.WrapError(err, "Addresses")
		return
	}
	for za0001 := range z.Addresses {
		err = en.WriteString(z.Addresses[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Addresses", za0001)
			return
		}
	}
	// write "Flags"
	err = en.Append(0xa5, 0x46, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint(z.Flags)
	if err != nil {
		err = msgp.WrapError(err, "Flags")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *NetworkInterfaceInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Name"
	o = append(o, 0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "MACAddress"
	o = append(o, 0xaa, 0x4d, 0x41, 0x43, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.MACAddress)
	// string "Addresses"
	o = append(o, 0xa9, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Addresses)))
	for za0001 := range z.Addresses {
		o = msgp.AppendString(o, z.Addresses[za0001])
	}
	// string "Flags"
	o = append(o, 0xa5, 0x46, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint(o, z.Flags)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NetworkInterfaceInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "MACAddress":
			z.MACAddress, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MACAddress")
				return
			}
		case "Addresses":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Addresses")
				return
			}
			if cap(z.Addresses) >= int(zb0002) {
				z.Addresses = (z.Addresses)[:zb0002]
			} else {
				z.Addresses = make([]string, zb0002)
			}
			for za0001 := range z.Addresses {
				z.Addresses[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Addresses", za0001)
					return
				}
			}
		case "Flags":
			z.Flags, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NetworkInterfaceInfo) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + msgp.StringPrefixSize + len(z.MACAddress) + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.Addresses {
		s += msgp.StringPrefixSize + len(z.Addresses[za0001])
	}
	s += 6 + msgp.UintSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Principal) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "GroupID":
			z.GroupID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GroupID")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "UserID":
			z.UserID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "LogonType":
			z.LogonType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LogonType")
				return
			}
		case "RunLevel":
			z.RunLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RunLevel")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Principal) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "Name"
	err = en.Append(0x86, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "GroupID"
	err = en.Append(0xa7, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.GroupID)
	if err != nil {
		err = msgp.WrapError(err, "GroupID")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "UserID"
	err = en.Append(0xa6, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.UserID)
	if err != nil {
		err = msgp.WrapError(err, "UserID")
		return
	}
	// write "LogonType"
	err = en.Append(0xa9, 0x4c, 0x6f, 0x67, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LogonType)
	if err != nil {
		err = msgp.WrapError(err, "LogonType")
		return
	}
	// write "RunLevel"
	err = en.Append(0xa8, 0x52, 0x75, 0x6e, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RunLevel)
	if err != nil {
		err = msgp.WrapError(err, "RunLevel")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Principal) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "Name"
	o = append(o, 0x86, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "GroupID"
	o = append(o, 0xa7, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44)
	o = msgp.AppendString(o, z.GroupID)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "UserID"
	o = append(o, 0xa6, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.UserID)
	// string "LogonType"
	o = append(o, 0xa9, 0x4c, 0x6f, 0x67, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, z.LogonType)
	// string "RunLevel"
	o = append(o, 0xa8, 0x52, 0x75, 0x6e, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.RunLevel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Principal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "GroupID":
			z.GroupID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GroupID")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "UserID":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "LogonType":
			z.LogonType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LogonType")
				return
			}
		case "RunLevel":
			z.RunLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RunLevel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Principal) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 8 + msgp.StringPrefixSize + len(z.GroupID) + 3 + msgp.StringPrefixSize + len(z.ID) + 7 + msgp.StringPrefixSize + len(z.UserID) + 10 + msgp.IntSize + 9 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Privilege) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "AssignedSIDs":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AssignedSIDs")
				return
			}
			if cap(z.AssignedSIDs) >= int(zb0002) {
				z.AssignedSIDs = (z.AssignedSIDs)[:zb0002]
			} else {
				z.AssignedSIDs = make([]string, zb0002)
			}
			for za0001 := range z.AssignedSIDs {
				z.AssignedSIDs[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AssignedSIDs", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Privilege) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Name"
	err = en.Append(0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "AssignedSIDs"
	err = en.Append(0xac, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x53, 0x49, 0x44, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AssignedSIDs)))
	if err != nil {
		err = msgp.WrapError(err, "AssignedSIDs")
		return
	}
	for za0001 := range z.AssignedSIDs {
		err = en.WriteString(z.AssignedSIDs[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AssignedSIDs", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Privilege) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Name"
	o = append(o, 0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "AssignedSIDs"
	o = append(o, 0xac, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x53, 0x49, 0x44, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AssignedSIDs)))
	for za0001 := range z.AssignedSIDs {
		o = msgp.AppendString(o, z.AssignedSIDs[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Privilege) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "AssignedSIDs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AssignedSIDs")
				return
			}
			if cap(z.AssignedSIDs) >= int(zb0002) {
				z.AssignedSIDs = (z.AssignedSIDs)[:zb0002]
			} else {
				z.AssignedSIDs = make([]string, zb0002)
			}
			for za0001 := range z.AssignedSIDs {
				z.AssignedSIDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssignedSIDs", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Privilege) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 13 + msgp.ArrayHeaderSize
	for za0001 := range z.AssignedSIDs {
		s += msgp.StringPrefixSize + len(z.AssignedSIDs[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Privileges) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0003) {
		(*z) = (*z)[:zb0003]
	} else {
		(*z) = make(Privileges, zb0003)
	}
	for zb0001 := range *z {
		var field []byte
		_ = field
		var zb0004 uint32
		zb0004, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		for zb0004 > 0 {
			zb0004--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "Name":
				(*z)[zb0001].Name, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Name")
					return
				}
			case "AssignedSIDs":
				var zb0005 uint32
				zb0005, err = dc.ReadArrayHeader()
				if err != nil {
					err = msgp.WrapError(err, zb0001, "AssignedSIDs")
					return
				}
				if cap((*z)[zb0001].AssignedSIDs) >= int(zb0005) {
					(*z)[zb0001].AssignedSIDs = ((*z)[zb0001].AssignedSIDs)[:zb0005]
				} else {
					(*z)[zb0001].AssignedSIDs = make([]string, zb0005)
				}
				for zb0002 := range (*z)[zb0001].AssignedSIDs {
					(*z)[zb0001].AssignedSIDs[zb0002], err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, zb0001, "AssignedSIDs", zb0002)
						return
					}
				}
			default:
				err = dc.Skip()
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Privileges) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0006 := range z {
		// map header, size 2
		// write "Name"
		err = en.Append(0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z[zb0006].Name)
		if err != nil {
			err = msgp.WrapError(err, zb0006, "Name")
			return
		}
		// write "AssignedSIDs"
		err = en.Append(0xac, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x53, 0x49, 0x44, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z[zb0006].AssignedSIDs)))
		if err != nil {
			err = msgp.WrapError(err, zb0006, "AssignedSIDs")
			return
		}
		for zb0007 := range z[zb0006].AssignedSIDs {
			err = en.WriteString(z[zb0006].AssignedSIDs[zb0007])
			if err != nil {
				err = msgp.WrapError(err, zb0006, "AssignedSIDs", zb0007)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Privileges) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0006 := range z {
		// map header, size 2
		// string "Name"
		o = append(o, 0x82, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z[zb0006].Name)
		// string "AssignedSIDs"
		o = append(o, 0xac, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x53, 0x49, 0x44, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z[zb0006].AssignedSIDs)))
		for zb0007 := range z[zb0006].AssignedSIDs {
			o = msgp.AppendString(o, z[zb0006].AssignedSIDs[zb0007])
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Privileges) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0003) {
		(*z) = (*z)[:zb0003]
	} else {
		(*z) = make(Privileges, zb0003)
	}
	for zb0001 := range *z {
		var field []byte
		_ = field
		var zb0004 uint32
		zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "Name":
				(*z)[zb0001].Name, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Name")
					return
				}
			case "AssignedSIDs":
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "AssignedSIDs")
					return
				}
				if cap((*z)[zb0001].AssignedSIDs) >= int(zb0005) {
					(*z)[zb0001].AssignedSIDs = ((*z)[zb0001].AssignedSIDs)[:zb0005]
				} else {
					(*z)[zb0001].AssignedSIDs = make([]string, zb0005)
				}
				for zb0002 := range (*z)[zb0001].AssignedSIDs {
					(*z)[zb0001].AssignedSIDs[zb0002], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, zb0001, "AssignedSIDs", zb0002)
						return
					}
				}
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Privileges) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0006 := range z {
		s += 1 + 5 + msgp.StringPrefixSize + len(z[zb0006].Name) + 13 + msgp.ArrayHeaderSize
		for zb0007 := range z[zb0006].AssignedSIDs {
			s += msgp.StringPrefixSize + len(z[zb0006].AssignedSIDs[zb0007])
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RegisteredTask) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NextRunTime":
			z.NextRunTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "NextRunTime")
				return
			}
		case "LastRunTime":
			z.LastRunTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastRunTime")
				return
			}
		case "Definition":
			err = z.Definition.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Definition")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "State":
			z.State, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		case "MissedRuns":
			z.MissedRuns, err = dc.ReadUint()
			if err != nil {
				err = msgp.WrapError(err, "MissedRuns")
				return
			}
		case "LastTaskResult":
			z.LastTaskResult, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "LastTaskResult")
				return
			}
		case "Enabled":
			z.Enabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RegisteredTask) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "NextRunTime"
	err = en.Append(0x89, 0xab, 0x4e, 0x65, 0x78, 0x74, 0x52, 0x75, 0x6e, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.NextRunTime)
	if err != nil {
		err = msgp.WrapError(err, "NextRunTime")
		return
	}
	// write "LastRunTime"
	err = en.Append(0xab, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x75, 0x6e, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastRunTime)
	if err != nil {
		err = msgp.WrapError(err, "LastRunTime")
		return
	}
	// write "Definition"
	err = en.Append(0xaa, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = z.Definition.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Definition")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "Path"
	err = en.Append(0xa4, 0x50, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "State"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.State)
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	// write "MissedRuns"
	err = en.Append(0xaa, 0x4d, 0x69, 0x73, 0x73, 0x65, 0x64, 0x52, 0x75, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint(z.MissedRuns)
	if err != nil {
		err = msgp.WrapError(err, "MissedRuns")
		return
	}
	// write "LastTaskResult"
	err = en.Append(0xae, 0x4c, 0x61, 0x73, 0x74, 0x54, 0x61, 0x73, 0x6b, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.LastTaskResult)
	if err != nil {
		err = msgp.WrapError(err, "LastTaskResult")
		return
	}
	// write "Enabled"
	err = en.Append(0xa7, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Enabled)
	if err != nil {
		err = msgp.WrapError(err, "Enabled")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RegisteredTask) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "NextRunTime"
	o = append(o, 0x89, 0xab, 0x4e, 0x65, 0x78, 0x74, 0x52, 0x75, 0x6e, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.NextRunTime)
	// string "LastRunTime"
	o = append(o, 0xab, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x75, 0x6e, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.LastRunTime)
	// string "Definition"
	o = append(o, 0xaa, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e)
	o, err = z.Definition.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Definition")
		return
	}
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "Path"
	o = append(o, 0xa4, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "State"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.State)
	// string "MissedRuns"
	o = append(o, 0xaa, 0x4d, 0x69, 0x73, 0x73, 0x65, 0x64, 0x52, 0x75, 0x6e, 0x73)
	o = msgp.AppendUint(o, z.MissedRuns)
	// string "LastTaskResult"
	o = append(o, 0xae, 0x4c, 0x61, 0x73, 0x74, 0x54, 0x61, 0x73, 0x6b, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74)
	o = msgp.AppendUint32(o, z.LastTaskResult)
	// string "Enabled"
	o = append(o, 0xa7, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Enabled)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RegisteredTask) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NextRunTime":
			z.NextRunTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NextRunTime")
				return
			}
		case "LastRunTime":
			z.LastRunTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastRunTime")
				return
			}
		case "Definition":
			bts, err = z.Definition.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Definition")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "State":
			z.State, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		case "MissedRuns":
			z.MissedRuns, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MissedRuns")
				return
			}
		case "LastTaskResult":
			z.LastTaskResult, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastTaskResult")
				return
			}
		case "Enabled":
			z.Enabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RegisteredTask) Msgsize() (s int) {
	s = 1 + 12 + msgp.TimeSize + 12 + msgp.TimeSize + 11 + z.Definition.Msgsize() + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Path) + 6 + msgp.StringPrefixSize + len(z.State) + 11 + msgp.UintSize + 15 + msgp.Uint32Size + 8 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RegistrationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Author":
			z.Author, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Author")
				return
			}
		case "Date":
			z.Date, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Description":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "Documentation":
			z.Documentation, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Documentation")
				return
			}
		case "SecurityDescriptor":
			z.SecurityDescriptor, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SecurityDescriptor")
				return
			}
		case "Source":
			z.Source, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "URI":
			z.URI, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "URI")
				return
			}
		case "Version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RegistrationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "Author"
	err = en.Append(0x88, 0xa6, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Author)
	if err != nil {
		err = msgp.WrapError(err, "Author")
		return
	}
	// write "Date"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Date)
	if err != nil {
		err = msgp.WrapError(err, "Date")
		return
	}
	// write "Description"
	err = en.Append(0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "Documentation"
	err = en.Append(0xad, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Documentation)
	if err != nil {
		err = msgp.WrapError(err, "Documentation")
		return
	}
	// write "SecurityDescriptor"
	err = en.Append(0xb2, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.SecurityDescriptor)
	if err != nil {
		err = msgp.WrapError(err, "SecurityDescriptor")
		return
	}
	// write "Source"
	err = en.Append(0xa6, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Source)
	if err != nil {
		err = msgp.WrapError(err, "Source")
		return
	}
	// write "URI"
	err = en.Append(0xa3, 0x55, 0x52, 0x49)
	if err != nil {
		return
	}
	err = en.WriteString(z.URI)
	if err != nil {
		err = msgp.WrapError(err, "URI")
		return
	}
	// write "Version"
	err = en.Append(0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RegistrationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "Author"
	o = append(o, 0x88, 0xa6, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Author)
	// string "Date"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendTime(o, z.Date)
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "Documentation"
	o = append(o, 0xad, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Documentation)
	// string "SecurityDescriptor"
	o = append(o, 0xb2, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72)
	o = msgp.AppendString(o, z.SecurityDescriptor)
	// string "Source"
	o = append(o, 0xa6, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65)
	o = msgp.AppendString(o, z.Source)
	// string "URI"
	o = append(o, 0xa3, 0x55, 0x52, 0x49)
	o = msgp.AppendString(o, z.URI)
	// string "Version"
	o = append(o, 0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Version)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RegistrationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Author":
			z.Author, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Author")
				return
			}
		case "Date":
			z.Date, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "Documentation":
			z.Documentation, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Documentation")
				return
			}
		case "SecurityDescriptor":
			z.SecurityDescriptor, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SecurityDescriptor")
				return
			}
		case "Source":
			z.Source, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "URI":
			z.URI, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URI")
				return
			}
		case "Version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RegistrationInfo) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Author) + 5 + msgp.TimeSize + 12 + msgp.StringPrefixSize + len(z.Description) + 14 + msgp.StringPrefixSize + len(z.Documentation) + 19 + msgp.StringPrefixSize + len(z.SecurityDescriptor) + 7 + msgp.StringPrefixSize + len(z.Source) + 4 + msgp.StringPrefixSize + len(z.URI) + 8 + msgp.StringPrefixSize + len(z.Version)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RegistryData) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0003 uint32
	zb0003, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(RegistryData, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		zb0003--
		var zb0001 string
		var zb0002 interface{}
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		zb0002, err = dc.ReadIntf()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z RegistryData) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0004, zb0005 := range z {
		err = en.WriteString(zb0004)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		err = en.WriteIntf(zb0005)
		if err != nil {
			err = msgp.WrapError(err, zb0004)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z RegistryData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for zb0004, zb0005 := range z {
		o = msgp.AppendString(o, zb0004)
		o, err = msgp.AppendIntf(o, zb0005)
		if err != nil {
			err = msgp.WrapError(err, zb0004)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RegistryData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(RegistryData, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		var zb0001 string
		var zb0002 interface{}
		zb0003--
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		zb0002, bts, err = msgp.ReadIntfBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z RegistryData) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0004, zb0005 := range z {
			_ = zb0005
			s += msgp.StringPrefixSize + len(zb0004) + msgp.GuessSize(zb0005)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Service) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "RegistryOwner":
			z.RegistryOwner, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RegistryOwner")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "DisplayName":
			z.DisplayName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "Description":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "ImagePath":
			z.ImagePath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImagePath")
				return
			}
		case "ImageExecutable":
			z.ImageExecutable, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImageExecutable")
				return
			}
		case "ImageExecutableOwner":
			z.ImageExecutableOwner, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ImageExecutableOwner")
				return
			}
		case "Account":
			z.Account, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Account")
				return
			}
		case "AccountSID":
			z.AccountSID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AccountSID")
				return
			}
		case "RegistryDACL":
			z.RegistryDACL, err = dc.ReadBytes(z.RegistryDACL)
			if err != nil {
				err = msgp.WrapError(err, "RegistryDACL")
				return
			}
		case "ImageExecutableDACL":
			z.ImageExecutableDACL, err = dc.ReadBytes(z.ImageExecutableDACL)
			if err != nil {
				err = msgp.WrapError(err, "ImageExecutableDACL")
				return
			}
		case "RequiredPrivileges":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "RequiredPrivileges")
				return
			}
			if cap(z.RequiredPrivileges) >= int(zb0002) {
				z.RequiredPrivileges = (z.RequiredPrivileges)[:zb0002]
			} else {
				z.RequiredPrivileges = make([]string, zb0002)
			}
			for za0001 := range z.RequiredPrivileges {
				z.RequiredPrivileges[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RequiredPrivileges", za0001)
					return
				}
			}
		case "Start":
			z.Start, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Start")
				return
			}
		case "Type":
			z.Type, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Service) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "RegistryOwner"
	err = en.Append(0x8e, 0xad, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.RegistryOwner)
	if err != nil {
		err = msgp.WrapError(err, "RegistryOwner")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "DisplayName"
	err = en.Append(0xab, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayName)
	if err != nil {
		err = msgp.WrapError(err, "DisplayName")
		return
	}
	// write "Description"
	err = en.Append(0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "ImagePath"
	err = en.Append(0xa9, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x50, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImagePath)
	if err != nil {
		err = msgp.WrapError(err, "ImagePath")
		return
	}
	// write "ImageExecutable"
	err = en.Append(0xaf, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImageExecutable)
	if err != nil {
		err = msgp.WrapError(err, "ImageExecutable")
		return
	}
	// write "ImageExecutableOwner"
	err = en.Append(0xb4, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.ImageExecutableOwner)
	if err != nil {
		err = msgp.WrapError(err, "ImageExecutableOwner")
		return
	}
	// write "Account"
	err = en.Append(0xa7, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Account)
	if err != nil {
		err = msgp.WrapError(err, "Account")
		return
	}
	// write "AccountSID"
	err = en.Append(0xaa, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.AccountSID)
	if err != nil {
		err = msgp.WrapError(err, "AccountSID")
		return
	}
	// write "RegistryDACL"
	err = en.Append(0xac, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x44, 0x41, 0x43, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.RegistryDACL)
	if err != nil {
		err = msgp.WrapError(err, "RegistryDACL")
		return
	}
	// write "ImageExecutableDACL"
	err = en.Append(0xb3, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x41, 0x43, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.ImageExecutableDACL)
	if err != nil {
		err = msgp.WrapError(err, "ImageExecutableDACL")
		return
	}
	// write "RequiredPrivileges"
	err = en.Append(0xb2, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RequiredPrivileges)))
	if err != nil {
		err = msgp.WrapError(err, "RequiredPrivileges")
		return
	}
	for za0001 := range z.RequiredPrivileges {
		err = en.WriteString(z.RequiredPrivileges[za0001])
		if err != nil {
			err = msgp.WrapError(err, "RequiredPrivileges", za0001)
			return
		}
	}
	// write "Start"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Start)
	if err != nil {
		err = msgp.WrapError(err, "Start")
		return
	}
	// write "Type"
	err = en.Append(0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Service) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "RegistryOwner"
	o = append(o, 0x8e, 0xad, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.RegistryOwner)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "DisplayName"
	o = append(o, 0xab, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.DisplayName)
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "ImagePath"
	o = append(o, 0xa9, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.ImagePath)
	// string "ImageExecutable"
	o = append(o, 0xaf, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendString(o, z.ImageExecutable)
	// string "ImageExecutableOwner"
	o = append(o, 0xb4, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.ImageExecutableOwner)
	// string "Account"
	o = append(o, 0xa7, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Account)
	// string "AccountSID"
	o = append(o, 0xaa, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.AccountSID)
	// string "RegistryDACL"
	o = append(o, 0xac, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x44, 0x41, 0x43, 0x4c)
	o = msgp.AppendBytes(o, z.RegistryDACL)
	// string "ImageExecutableDACL"
	o = append(o, 0xb3, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x41, 0x43, 0x4c)
	o = msgp.AppendBytes(o, z.ImageExecutableDACL)
	// string "RequiredPrivileges"
	o = append(o, 0xb2, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RequiredPrivileges)))
	for za0001 := range z.RequiredPrivileges {
		o = msgp.AppendString(o, z.RequiredPrivileges[za0001])
	}
	// string "Start"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
	o = msgp.AppendInt(o, z.Start)
	// string "Type"
	o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Service) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "RegistryOwner":
			z.RegistryOwner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RegistryOwner")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "DisplayName":
			z.DisplayName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "ImagePath":
			z.ImagePath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImagePath")
				return
			}
		case "ImageExecutable":
			z.ImageExecutable, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImageExecutable")
				return
			}
		case "ImageExecutableOwner":
			z.ImageExecutableOwner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImageExecutableOwner")
				return
			}
		case "Account":
			z.Account, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Account")
				return
			}
		case "AccountSID":
			z.AccountSID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AccountSID")
				return
			}
		case "RegistryDACL":
			z.RegistryDACL, bts, err = msgp.ReadBytesBytes(bts, z.RegistryDACL)
			if err != nil {
				err = msgp.WrapError(err, "RegistryDACL")
				return
			}
		case "ImageExecutableDACL":
			z.ImageExecutableDACL, bts, err = msgp.ReadBytesBytes(bts, z.ImageExecutableDACL)
			if err != nil {
				err = msgp.WrapError(err, "ImageExecutableDACL")
				return
			}
		case "RequiredPrivileges":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequiredPrivileges")
				return
			}
			if cap(z.RequiredPrivileges) >= int(zb0002) {
				z.RequiredPrivileges = (z.RequiredPrivileges)[:zb0002]
			} else {
				z.RequiredPrivileges = make([]string, zb0002)
			}
			for za0001 := range z.RequiredPrivileges {
				z.RequiredPrivileges[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RequiredPrivileges", za0001)
					return
				}
			}
		case "Start":
			z.Start, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Start")
				return
			}
		case "Type":
			z.Type, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Service) Msgsize() (s int) {
	s = 1 + 14 + msgp.StringPrefixSize + len(z.RegistryOwner) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.DisplayName) + 12 + msgp.StringPrefixSize + len(z.Description) + 10 + msgp.StringPrefixSize + len(z.ImagePath) + 16 + msgp.StringPrefixSize + len(z.ImageExecutable) + 21 + msgp.StringPrefixSize + len(z.ImageExecutableOwner) + 8 + msgp.StringPrefixSize + len(z.Account) + 11 + msgp.StringPrefixSize + len(z.AccountSID) + 13 + msgp.BytesPrefixSize + len(z.RegistryDACL) + 20 + msgp.BytesPrefixSize + len(z.ImageExecutableDACL) + 19 + msgp.ArrayHeaderSize
	for za0001 := range z.RequiredPrivileges {
		s += msgp.StringPrefixSize + len(z.RequiredPrivileges[za0001])
	}
	s += 6 + msgp.IntSize + 5 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Services) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Services, zb0002)
	}
	for zb0001 := range *z {
		err = (*z)[zb0001].DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Services) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		err = z[zb0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Services) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0003 := range z {
		o, err = z[zb0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Services) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Services, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Services) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		s += z[zb0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Share) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "Remark":
			z.Remark, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Remark")
				return
			}
		case "PathOwner":
			z.PathOwner, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathOwner")
				return
			}
		case "DACL":
			z.DACL, err = dc.ReadBytes(z.DACL)
			if err != nil {
				err = msgp.WrapError(err, "DACL")
				return
			}
		case "PathDACL":
			z.PathDACL, err = dc.ReadBytes(z.PathDACL)
			if err != nil {
				err = msgp.WrapError(err, "PathDACL")
				return
			}
		case "Permissions":
			z.Permissions, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
		case "Type":
			z.Type, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Share) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "Name"
	err = en.Append(0x88, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "Path"
	err = en.Append(0xa4, 0x50, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "Remark"
	err = en.Append(0xa6, 0x52, 0x65, 0x6d, 0x61, 0x72, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteString(z.Remark)
	if err != nil {
		err = msgp.WrapError(err, "Remark")
		return
	}
	// write "PathOwner"
	err = en.Append(0xa9, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathOwner)
	if err != nil {
		err = msgp.WrapError(err, "PathOwner")
		return
	}
	// write "DACL"
	err = en.Append(0xa4, 0x44, 0x41, 0x43, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.DACL)
	if err != nil {
		err = msgp.WrapError(err, "DACL")
		return
	}
	// write "PathDACL"
	err = en.Append(0xa8, 0x50, 0x61, 0x74, 0x68, 0x44, 0x41, 0x43, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.PathDACL)
	if err != nil {
		err = msgp.WrapError(err, "PathDACL")
		return
	}
	// write "Permissions"
	err = en.Append(0xab, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Permissions)
	if err != nil {
		err = msgp.WrapError(err, "Permissions")
		return
	}
	// write "Type"
	err = en.Append(0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Share) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "Name"
	o = append(o, 0x88, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "Path"
	o = append(o, 0xa4, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "Remark"
	o = append(o, 0xa6, 0x52, 0x65, 0x6d, 0x61, 0x72, 0x6b)
	o = msgp.AppendString(o, z.Remark)
	// string "PathOwner"
	o = append(o, 0xa9, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.PathOwner)
	// string "DACL"
	o = append(o, 0xa4, 0x44, 0x41, 0x43, 0x4c)
	o = msgp.AppendBytes(o, z.DACL)
	// string "PathDACL"
	o = append(o, 0xa8, 0x50, 0x61, 0x74, 0x68, 0x44, 0x41, 0x43, 0x4c)
	o = msgp.AppendBytes(o, z.PathDACL)
	// string "Permissions"
	o = append(o, 0xab, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendInt(o, z.Permissions)
	// string "Type"
	o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Share) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "Remark":
			z.Remark, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remark")
				return
			}
		case "PathOwner":
			z.PathOwner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathOwner")
				return
			}
		case "DACL":
			z.DACL, bts, err = msgp.ReadBytesBytes(bts, z.DACL)
			if err != nil {
				err = msgp.WrapError(err, "DACL")
				return
			}
		case "PathDACL":
			z.PathDACL, bts, err = msgp.ReadBytesBytes(bts, z.PathDACL)
			if err != nil {
				err = msgp.WrapError(err, "PathDACL")
				return
			}
		case "Permissions":
			z.Permissions, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
		case "Type":
			z.Type, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Share) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Path) + 7 + msgp.StringPrefixSize + len(z.Remark) + 10 + msgp.StringPrefixSize + len(z.PathOwner) + 5 + msgp.BytesPrefixSize + len(z.DACL) + 9 + msgp.BytesPrefixSize + len(z.PathDACL) + 12 + msgp.IntSize + 5 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Shares) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Shares, zb0002)
	}
	for zb0001 := range *z {
		err = (*z)[zb0001].DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Shares) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		err = z[zb0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Shares) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0003 := range z {
		o, err = z[zb0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Shares) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Shares, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Shares) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		s += z[zb0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Software) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "InstallDate":
			z.InstallDate, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "InstallDate")
				return
			}
		case "DisplayName":
			z.DisplayName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "DisplayVersion":
			z.DisplayVersion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayVersion")
				return
			}
		case "Arch":
			z.Arch, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Arch")
				return
			}
		case "Publisher":
			z.Publisher, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Publisher")
				return
			}
		case "Contact":
			z.Contact, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Contact")
				return
			}
		case "HelpLink":
			z.HelpLink, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HelpLink")
				return
			}
		case "InstallSource":
			z.InstallSource, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InstallSource")
				return
			}
		case "InstallLocation":
			z.InstallLocation, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InstallLocation")
				return
			}
		case "UninstallString":
			z.UninstallString, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UninstallString")
				return
			}
		case "EstimatedSize":
			z.EstimatedSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "EstimatedSize")
				return
			}
		case "VersionMajor":
			z.VersionMajor, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "VersionMajor")
				return
			}
		case "VersionMinor":
			z.VersionMinor, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "VersionMinor")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Software) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 13
	// write "InstallDate"
	err = en.Append(0x8d, 0xab, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x44, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.InstallDate)
	if err != nil {
		err = msgp.WrapError(err, "InstallDate")
		return
	}
	// write "DisplayName"
	err = en.Append(0xab, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayName)
	if err != nil {
		err = msgp.WrapError(err, "DisplayName")
		return
	}
	// write "DisplayVersion"
	err = en.Append(0xae, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayVersion)
	if err != nil {
		err = msgp.WrapError(err, "DisplayVersion")
		return
	}
	// write "Arch"
	err = en.Append(0xa4, 0x41, 0x72, 0x63, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Arch)
	if err != nil {
		err = msgp.WrapError(err, "Arch")
		return
	}
	// write "Publisher"
	err = en.Append(0xa9, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Publisher)
	if err != nil {
		err = msgp.WrapError(err, "Publisher")
		return
	}
	// write "Contact"
	err = en.Append(0xa7, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Contact)
	if err != nil {
		err = msgp.WrapError(err, "Contact")
		return
	}
	// write "HelpLink"
	err = en.Append(0xa8, 0x48, 0x65, 0x6c, 0x70, 0x4c, 0x69, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteString(z.HelpLink)
	if err != nil {
		err = msgp.WrapError(err, "HelpLink")
		return
	}
	// write "InstallSource"
	err = en.Append(0xad, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.InstallSource)
	if err != nil {
		err = msgp.WrapError(err, "InstallSource")
		return
	}
	// write "InstallLocation"
	err = en.Append(0xaf, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.InstallLocation)
	if err != nil {
		err = msgp.WrapError(err, "InstallLocation")
		return
	}
	// write "UninstallString"
	err = en.Append(0xaf, 0x55, 0x6e, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.UninstallString)
	if err != nil {
		err = msgp.WrapError(err, "UninstallString")
		return
	}
	// write "EstimatedSize"
	err = en.Append(0xad, 0x45, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.EstimatedSize)
	if err != nil {
		err = msgp.WrapError(err, "EstimatedSize")
		return
	}
	// write "VersionMajor"
	err = en.Append(0xac, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x61, 0x6a, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.VersionMajor)
	if err != nil {
		err = msgp.WrapError(err, "VersionMajor")
		return
	}
	// write "VersionMinor"
	err = en.Append(0xac, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x69, 0x6e, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.VersionMinor)
	if err != nil {
		err = msgp.WrapError(err, "VersionMinor")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Software) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "InstallDate"
	o = append(o, 0x8d, 0xab, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendTime(o, z.InstallDate)
	// string "DisplayName"
	o = append(o, 0xab, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.DisplayName)
	// string "DisplayVersion"
	o = append(o, 0xae, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.DisplayVersion)
	// string "Arch"
	o = append(o, 0xa4, 0x41, 0x72, 0x63, 0x68)
	o = msgp.AppendString(o, z.Arch)
	// string "Publisher"
	o = append(o, 0xa9, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x72)
	o = msgp.AppendString(o, z.Publisher)
	// string "Contact"
	o = append(o, 0xa7, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74)
	o = msgp.AppendString(o, z.Contact)
	// string "HelpLink"
	o = append(o, 0xa8, 0x48, 0x65, 0x6c, 0x70, 0x4c, 0x69, 0x6e, 0x6b)
	o = msgp.AppendString(o, z.HelpLink)
	// string "InstallSource"
	o = append(o, 0xad, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65)
	o = msgp.AppendString(o, z.InstallSource)
	// string "InstallLocation"
	o = append(o, 0xaf, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.InstallLocation)
	// string "UninstallString"
	o = append(o, 0xaf, 0x55, 0x6e, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	o = msgp.AppendString(o, z.UninstallString)
	// string "EstimatedSize"
	o = append(o, 0xad, 0x45, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.EstimatedSize)
	// string "VersionMajor"
	o = append(o, 0xac, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x61, 0x6a, 0x6f, 0x72)
	o = msgp.AppendUint64(o, z.VersionMajor)
	// string "VersionMinor"
	o = append(o, 0xac, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x69, 0x6e, 0x6f, 0x72)
	o = msgp.AppendUint64(o, z.VersionMinor)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Software) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "InstallDate":
			z.InstallDate, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InstallDate")
				return
			}
		case "DisplayName":
			z.DisplayName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "DisplayVersion":
			z.DisplayVersion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayVersion")
				return
			}
		case "Arch":
			z.Arch, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Arch")
				return
			}
		case "Publisher":
			z.Publisher, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Publisher")
				return
			}
		case "Contact":
			z.Contact, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Contact")
				return
			}
		case "HelpLink":
			z.HelpLink, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HelpLink")
				return
			}
		case "InstallSource":
			z.InstallSource, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InstallSource")
				return
			}
		case "InstallLocation":
			z.InstallLocation, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InstallLocation")
				return
			}
		case "UninstallString":
			z.UninstallString, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UninstallString")
				return
			}
		case "EstimatedSize":
			z.EstimatedSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EstimatedSize")
				return
			}
		case "VersionMajor":
			z.VersionMajor, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionMajor")
				return
			}
		case "VersionMinor":
			z.VersionMinor, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionMinor")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Software) Msgsize() (s int) {
	s = 1 + 12 + msgp.TimeSize + 12 + msgp.StringPrefixSize + len(z.DisplayName) + 15 + msgp.StringPrefixSize + len(z.DisplayVersion) + 5 + msgp.StringPrefixSize + len(z.Arch) + 10 + msgp.StringPrefixSize + len(z.Publisher) + 8 + msgp.StringPrefixSize + len(z.Contact) + 9 + msgp.StringPrefixSize + len(z.HelpLink) + 14 + msgp.StringPrefixSize + len(z.InstallSource) + 16 + msgp.StringPrefixSize + len(z.InstallLocation) + 16 + msgp.StringPrefixSize + len(z.UninstallString) + 14 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskAction) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "PathOwner":
			z.PathOwner, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathOwner")
				return
			}
		case "Path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "Args":
			z.Args, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Args")
				return
			}
		case "WorkingDir":
			z.WorkingDir, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WorkingDir")
				return
			}
		case "PathDACL":
			z.PathDACL, err = dc.ReadBytes(z.PathDACL)
			if err != nil {
				err = msgp.WrapError(err, "PathDACL")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskAction) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "Type"
	err = en.Append(0x86, 0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "PathOwner"
	err = en.Append(0xa9, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathOwner)
	if err != nil {
		err = msgp.WrapError(err, "PathOwner")
		return
	}
	// write "Path"
	err = en.Append(0xa4, 0x50, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "Args"
	err = en.Append(0xa4, 0x41, 0x72, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Args)
	if err != nil {
		err = msgp.WrapError(err, "Args")
		return
	}
	// write "WorkingDir"
	err = en.Append(0xaa, 0x57, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x44, 0x69, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.WorkingDir)
	if err != nil {
		err = msgp.WrapError(err, "WorkingDir")
		return
	}
	// write "PathDACL"
	err = en.Append(0xa8, 0x50, 0x61, 0x74, 0x68, 0x44, 0x41, 0x43, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.PathDACL)
	if err != nil {
		err = msgp.WrapError(err, "PathDACL")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskAction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "Type"
	o = append(o, 0x86, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "PathOwner"
	o = append(o, 0xa9, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.PathOwner)
	// string "Path"
	o = append(o, 0xa4, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "Args"
	o = append(o, 0xa4, 0x41, 0x72, 0x67, 0x73)
	o = msgp.AppendString(o, z.Args)
	// string "WorkingDir"
	o = append(o, 0xaa, 0x57, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x44, 0x69, 0x72)
	o = msgp.AppendString(o, z.WorkingDir)
	// string "PathDACL"
	o = append(o, 0xa8, 0x50, 0x61, 0x74, 0x68, 0x44, 0x41, 0x43, 0x4c)
	o = msgp.AppendBytes(o, z.PathDACL)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskAction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "PathOwner":
			z.PathOwner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathOwner")
				return
			}
		case "Path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "Args":
			z.Args, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Args")
				return
			}
		case "WorkingDir":
			z.WorkingDir, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WorkingDir")
				return
			}
		case "PathDACL":
			z.PathDACL, bts, err = msgp.ReadBytesBytes(bts, z.PathDACL)
			if err != nil {
				err = msgp.WrapError(err, "PathDACL")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskAction) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 10 + msgp.StringPrefixSize + len(z.PathOwner) + 5 + msgp.StringPrefixSize + len(z.Path) + 5 + msgp.StringPrefixSize + len(z.Args) + 11 + msgp.StringPrefixSize + len(z.WorkingDir) + 9 + msgp.BytesPrefixSize + len(z.PathDACL)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskDefinition) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "RegistrationInfo":
			err = z.RegistrationInfo.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "RegistrationInfo")
				return
			}
		case "Principal":
			err = z.Principal.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Principal")
				return
			}
		case "Context":
			z.Context, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Context")
				return
			}
		case "Data":
			z.Data, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "XMLText":
			z.XMLText, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "XMLText")
				return
			}
		case "Settings":
			err = z.Settings.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Settings")
				return
			}
		case "Actions":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Actions")
				return
			}
			if cap(z.Actions) >= int(zb0002) {
				z.Actions = (z.Actions)[:zb0002]
			} else {
				z.Actions = make([]TaskAction, zb0002)
			}
			for za0001 := range z.Actions {
				err = z.Actions[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Actions", za0001)
					return
				}
			}
		case "Triggers":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Triggers")
				return
			}
			if cap(z.Triggers) >= int(zb0003) {
				z.Triggers = (z.Triggers)[:zb0003]
			} else {
				z.Triggers = make([]string, zb0003)
			}
			for za0002 := range z.Triggers {
				z.Triggers[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Triggers", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskDefinition) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "RegistrationInfo"
	err = en.Append(0x88, 0xb0, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = z.RegistrationInfo.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "RegistrationInfo")
		return
	}
	// write "Principal"
	err = en.Append(0xa9, 0x50, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = z.Principal.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Principal")
		return
	}
	// write "Context"
	err = en.Append(0xa7, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Context)
	if err != nil {
		err = msgp.WrapError(err, "Context")
		return
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// write "XMLText"
	err = en.Append(0xa7, 0x58, 0x4d, 0x4c, 0x54, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.XMLText)
	if err != nil {
		err = msgp.WrapError(err, "XMLText")
		return
	}
	// write "Settings"
	err = en.Append(0xa8, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	if err != nil {
		return
	}
	err = z.Settings.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Settings")
		return
	}
	// write "Actions"
	err = en.Append(0xa7, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Actions)))
	if err != nil {
		err = msgp.WrapError(err, "Actions")
		return
	}
	for za0001 := range z.Actions {
		err = z.Actions[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Actions", za0001)
			return
		}
	}
	// write "Triggers"
	err = en.Append(0xa8, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Triggers)))
	if err != nil {
		err = msgp.WrapError(err, "Triggers")
		return
	}
	for za0002 := range z.Triggers {
		err = en.WriteString(z.Triggers[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Triggers", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskDefinition) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "RegistrationInfo"
	o = append(o, 0x88, 0xb0, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f)
	o, err = z.RegistrationInfo.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "RegistrationInfo")
		return
	}
	// string "Principal"
	o = append(o, 0xa9, 0x50, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c)
	o, err = z.Principal.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Principal")
		return
	}
	// string "Context"
	o = append(o, 0xa7, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.Context)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendString(o, z.Data)
	// string "XMLText"
	o = append(o, 0xa7, 0x58, 0x4d, 0x4c, 0x54, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.XMLText)
	// string "Settings"
	o = append(o, 0xa8, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o, err = z.Settings.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Settings")
		return
	}
	// string "Actions"
	o = append(o, 0xa7, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Actions)))
	for za0001 := range z.Actions {
		o, err = z.Actions[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Actions", za0001)
			return
		}
	}
	// string "Triggers"
	o = append(o, 0xa8, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Triggers)))
	for za0002 := range z.Triggers {
		o = msgp.AppendString(o, z.Triggers[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskDefinition) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "RegistrationInfo":
			bts, err = z.RegistrationInfo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "RegistrationInfo")
				return
			}
		case "Principal":
			bts, err = z.Principal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Principal")
				return
			}
		case "Context":
			z.Context, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Context")
				return
			}
		case "Data":
			z.Data, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "XMLText":
			z.XMLText, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "XMLText")
				return
			}
		case "Settings":
			bts, err = z.Settings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Settings")
				return
			}
		case "Actions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Actions")
				return
			}
			if cap(z.Actions) >= int(zb0002) {
				z.Actions = (z.Actions)[:zb0002]
			} else {
				z.Actions = make([]TaskAction, zb0002)
			}
			for za0001 := range z.Actions {
				bts, err = z.Actions[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Actions", za0001)
					return
				}
			}
		case "Triggers":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Triggers")
				return
			}
			if cap(z.Triggers) >= int(zb0003) {
				z.Triggers = (z.Triggers)[:zb0003]
			} else {
				z.Triggers = make([]string, zb0003)
			}
			for za0002 := range z.Triggers {
				z.Triggers[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Triggers", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskDefinition) Msgsize() (s int) {
	s = 1 + 17 + z.RegistrationInfo.Msgsize() + 10 + z.Principal.Msgsize() + 8 + msgp.StringPrefixSize + len(z.Context) + 5 + msgp.StringPrefixSize + len(z.Data) + 8 + msgp.StringPrefixSize + len(z.XMLText) + 9 + z.Settings.Msgsize() + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Actions {
		s += z.Actions[za0001].Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0002 := range z.Triggers {
		s += msgp.StringPrefixSize + len(z.Triggers[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskSettings) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DeleteExpiredTaskAfter":
			z.DeleteExpiredTaskAfter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DeleteExpiredTaskAfter")
				return
			}
		case "TimeLimit":
			z.TimeLimit, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TimeLimit")
				return
			}
		case "RestartInterval":
			z.RestartInterval, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RestartInterval")
				return
			}
		case "Priority":
			z.Priority, err = dc.ReadUint()
			if err != nil {
				err = msgp.WrapError(err, "Priority")
				return
			}
		case "RestartCount":
			z.RestartCount, err = dc.ReadUint()
			if err != nil {
				err = msgp.WrapError(err, "RestartCount")
				return
			}
		case "AllowDemandStart":
			z.AllowDemandStart, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AllowDemandStart")
				return
			}
		case "AllowHardTerminate":
			z.AllowHardTerminate, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AllowHardTerminate")
				return
			}
		case "DontStartOnBatteries":
			z.DontStartOnBatteries, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DontStartOnBatteries")
				return
			}
		case "Enabled":
			z.Enabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "Hidden":
			z.Hidden, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Hidden")
				return
			}
		case "RunOnlyIfIdle":
			z.RunOnlyIfIdle, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "RunOnlyIfIdle")
				return
			}
		case "RunOnlyIfNetworkAvailable":
			z.RunOnlyIfNetworkAvailable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "RunOnlyIfNetworkAvailable")
				return
			}
		case "StartWhenAvailable":
			z.StartWhenAvailable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "StartWhenAvailable")
				return
			}
		case "StopIfGoingOnBatteries":
			z.StopIfGoingOnBatteries, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "StopIfGoingOnBatteries")
				return
			}
		case "WakeToRun":
			z.WakeToRun, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "WakeToRun")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskSettings) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 15
	// write "DeleteExpiredTaskAfter"
	err = en.Append(0x8f, 0xb6, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64, 0x54, 0x61, 0x73, 0x6b, 0x41, 0x66, 0x74, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.DeleteExpiredTaskAfter)
	if err != nil {
		err = msgp.WrapError(err, "DeleteExpiredTaskAfter")
		return
	}
	// write "TimeLimit"
	err = en.Append(0xa9, 0x54, 0x69, 0x6d, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.TimeLimit)
	if err != nil {
		err = msgp.WrapError(err, "TimeLimit")
		return
	}
	// write "RestartInterval"
	err = en.Append(0xaf, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.RestartInterval)
	if err != nil {
		err = msgp.WrapError(err, "RestartInterval")
		return
	}
	// write "Priority"
	err = en.Append(0xa8, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint(z.Priority)
	if err != nil {
		err = msgp.WrapError(err, "Priority")
		return
	}
	// write "RestartCount"
	err = en.Append(0xac, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint(z.RestartCount)
	if err != nil {
		err = msgp.WrapError(err, "RestartCount")
		return
	}
	// write "AllowDemandStart"
	err = en.Append(0xb0, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x53, 0x74, 0x61, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AllowDemandStart)
	if err != nil {
		err = msgp.WrapError(err, "AllowDemandStart")
		return
	}
	// write "AllowHardTerminate"
	err = en.Append(0xb2, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x48, 0x61, 0x72, 0x64, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AllowHardTerminate)
	if err != nil {
		err = msgp.WrapError(err, "AllowHardTerminate")
		return
	}
	// write "DontStartOnBatteries"
	err = en.Append(0xb4, 0x44, 0x6f, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4f, 0x6e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.DontStartOnBatteries)
	if err != nil {
		err = msgp.WrapError(err, "DontStartOnBatteries")
		return
	}
	// write "Enabled"
	err = en.Append(0xa7, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Enabled)
	if err != nil {
		err = msgp.WrapError(err, "Enabled")
		return
	}
	// write "Hidden"
	err = en.Append(0xa6, 0x48, 0x69, 0x64, 0x64, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Hidden)
	if err != nil {
		err = msgp.WrapError(err, "Hidden")
		return
	}
	// write "RunOnlyIfIdle"
	err = en.Append(0xad, 0x52, 0x75, 0x6e, 0x4f, 0x6e, 0x6c, 0x79, 0x49, 0x66, 0x49, 0x64, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.RunOnlyIfIdle)
	if err != nil {
		err = msgp.WrapError(err, "RunOnlyIfIdle")
		return
	}
	// write "RunOnlyIfNetworkAvailable"
	err = en.Append(0xb9, 0x52, 0x75, 0x6e, 0x4f, 0x6e, 0x6c, 0x79, 0x49, 0x66, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.RunOnlyIfNetworkAvailable)
	if err != nil {
		err = msgp.WrapError(err, "RunOnlyIfNetworkAvailable")
		return
	}
	// write "StartWhenAvailable"
	err = en.Append(0xb2, 0x53, 0x74, 0x61, 0x72, 0x74, 0x57, 0x68, 0x65, 0x6e, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.StartWhenAvailable)
	if err != nil {
		err = msgp.WrapError(err, "StartWhenAvailable")
		return
	}
	// write "StopIfGoingOnBatteries"
	err = en.Append(0xb6, 0x53, 0x74, 0x6f, 0x70, 0x49, 0x66, 0x47, 0x6f, 0x69, 0x6e, 0x67, 0x4f, 0x6e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.StopIfGoingOnBatteries)
	if err != nil {
		err = msgp.WrapError(err, "StopIfGoingOnBatteries")
		return
	}
	// write "WakeToRun"
	err = en.Append(0xa9, 0x57, 0x61, 0x6b, 0x65, 0x54, 0x6f, 0x52, 0x75, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.WakeToRun)
	if err != nil {
		err = msgp.WrapError(err, "WakeToRun")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskSettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 15
	// string "DeleteExpiredTaskAfter"
	o = append(o, 0x8f, 0xb6, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64, 0x54, 0x61, 0x73, 0x6b, 0x41, 0x66, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.DeleteExpiredTaskAfter)
	// string "TimeLimit"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74)
	o = msgp.AppendString(o, z.TimeLimit)
	// string "RestartInterval"
	o = append(o, 0xaf, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	o = msgp.AppendString(o, z.RestartInterval)
	// string "Priority"
	o = append(o, 0xa8, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendUint(o, z.Priority)
	// string "RestartCount"
	o = append(o, 0xac, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint(o, z.RestartCount)
	// string "AllowDemandStart"
	o = append(o, 0xb0, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x53, 0x74, 0x61, 0x72, 0x74)
	o = msgp.AppendBool(o, z.AllowDemandStart)
	// string "AllowHardTerminate"
	o = append(o, 0xb2, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x48, 0x61, 0x72, 0x64, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65)
	o = msgp.AppendBool(o, z.AllowHardTerminate)
	// string "DontStartOnBatteries"
	o = append(o, 0xb4, 0x44, 0x6f, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4f, 0x6e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendBool(o, z.DontStartOnBatteries)
	// string "Enabled"
	o = append(o, 0xa7, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Enabled)
	// string "Hidden"
	o = append(o, 0xa6, 0x48, 0x69, 0x64, 0x64, 0x65, 0x6e)
	o = msgp.AppendBool(o, z.Hidden)
	// string "RunOnlyIfIdle"
	o = append(o, 0xad, 0x52, 0x75, 0x6e, 0x4f, 0x6e, 0x6c, 0x79, 0x49, 0x66, 0x49, 0x64, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.RunOnlyIfIdle)
	// string "RunOnlyIfNetworkAvailable"
	o = append(o, 0xb9, 0x52, 0x75, 0x6e, 0x4f, 0x6e, 0x6c, 0x79, 0x49, 0x66, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.RunOnlyIfNetworkAvailable)
	// string "StartWhenAvailable"
	o = append(o, 0xb2, 0x53, 0x74, 0x61, 0x72, 0x74, 0x57, 0x68, 0x65, 0x6e, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.StartWhenAvailable)
	// string "StopIfGoingOnBatteries"
	o = append(o, 0xb6, 0x53, 0x74, 0x6f, 0x70, 0x49, 0x66, 0x47, 0x6f, 0x69, 0x6e, 0x67, 0x4f, 0x6e, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendBool(o, z.StopIfGoingOnBatteries)
	// string "WakeToRun"
	o = append(o, 0xa9, 0x57, 0x61, 0x6b, 0x65, 0x54, 0x6f, 0x52, 0x75, 0x6e)
	o = msgp.AppendBool(o, z.WakeToRun)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskSettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DeleteExpiredTaskAfter":
			z.DeleteExpiredTaskAfter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteExpiredTaskAfter")
				return
			}
		case "TimeLimit":
			z.TimeLimit, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TimeLimit")
				return
			}
		case "RestartInterval":
			z.RestartInterval, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RestartInterval")
				return
			}
		case "Priority":
			z.Priority, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Priority")
				return
			}
		case "RestartCount":
			z.RestartCount, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RestartCount")
				return
			}
		case "AllowDemandStart":
			z.AllowDemandStart, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllowDemandStart")
				return
			}
		case "AllowHardTerminate":
			z.AllowHardTerminate, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllowHardTerminate")
				return
			}
		case "DontStartOnBatteries":
			z.DontStartOnBatteries, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DontStartOnBatteries")
				return
			}
		case "Enabled":
			z.Enabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "Hidden":
			z.Hidden, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hidden")
				return
			}
		case "RunOnlyIfIdle":
			z.RunOnlyIfIdle, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RunOnlyIfIdle")
				return
			}
		case "RunOnlyIfNetworkAvailable":
			z.RunOnlyIfNetworkAvailable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RunOnlyIfNetworkAvailable")
				return
			}
		case "StartWhenAvailable":
			z.StartWhenAvailable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartWhenAvailable")
				return
			}
		case "StopIfGoingOnBatteries":
			z.StopIfGoingOnBatteries, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StopIfGoingOnBatteries")
				return
			}
		case "WakeToRun":
			z.WakeToRun, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WakeToRun")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskSettings) Msgsize() (s int) {
	s = 1 + 23 + msgp.StringPrefixSize + len(z.DeleteExpiredTaskAfter) + 10 + msgp.StringPrefixSize + len(z.TimeLimit) + 16 + msgp.StringPrefixSize + len(z.RestartInterval) + 9 + msgp.UintSize + 13 + msgp.UintSize + 17 + msgp.BoolSize + 19 + msgp.BoolSize + 21 + msgp.BoolSize + 8 + msgp.BoolSize + 7 + msgp.BoolSize + 14 + msgp.BoolSize + 26 + msgp.BoolSize + 19 + msgp.BoolSize + 23 + msgp.BoolSize + 10 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *User) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PasswordLastSet":
			z.PasswordLastSet, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "PasswordLastSet")
				return
			}
		case "LastLogon":
			z.LastLogon, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastLogon")
				return
			}
		case "LastLogoff":
			z.LastLogoff, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastLogoff")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		case "FullName":
			z.FullName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FullName")
				return
			}
		case "BadPasswordCount":
			z.BadPasswordCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BadPasswordCount")
				return
			}
		case "NumberOfLogins":
			z.NumberOfLogins, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NumberOfLogins")
				return
			}
		case "IsEnabled":
			z.IsEnabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsEnabled")
				return
			}
		case "IsLocked":
			z.IsLocked, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsLocked")
				return
			}
		case "IsAdmin":
			z.IsAdmin, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsAdmin")
				return
			}
		case "PasswordNeverExpires":
			z.PasswordNeverExpires, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "PasswordNeverExpires")
				return
			}
		case "NoChangePassword":
			z.NoChangePassword, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NoChangePassword")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *User) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 13
	// write "PasswordLastSet"
	err = en.Append(0x8d, 0xaf, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x4c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteTime(z.PasswordLastSet)
	if err != nil {
		err = msgp.WrapError(err, "PasswordLastSet")
		return
	}
	// write "LastLogon"
	err = en.Append(0xa9, 0x4c, 0x61, 0x73, 0x74, 0x4c, 0x6f, 0x67, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastLogon)
	if err != nil {
		err = msgp.WrapError(err, "LastLogon")
		return
	}
	// write "LastLogoff"
	err = en.Append(0xaa, 0x4c, 0x61, 0x73, 0x74, 0x4c, 0x6f, 0x67, 0x6f, 0x66, 0x66)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastLogoff)
	if err != nil {
		err = msgp.WrapError(err, "LastLogoff")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "SID"
	err = en.Append(0xa3, 0x53, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.SID)
	if err != nil {
		err = msgp.WrapError(err, "SID")
		return
	}
	// write "FullName"
	err = en.Append(0xa8, 0x46, 0x75, 0x6c, 0x6c, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.FullName)
	if err != nil {
		err = msgp.WrapError(err, "FullName")
		return
	}
	// write "BadPasswordCount"
	err = en.Append(0xb0, 0x42, 0x61, 0x64, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BadPasswordCount)
	if err != nil {
		err = msgp.WrapError(err, "BadPasswordCount")
		return
	}
	// write "NumberOfLogins"
	err = en.Append(0xae, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f, 0x66, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.NumberOfLogins)
	if err != nil {
		err = msgp.WrapError(err, "NumberOfLogins")
		return
	}
	// write "IsEnabled"
	err = en.Append(0xa9, 0x49, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsEnabled)
	if err != nil {
		err = msgp.WrapError(err, "IsEnabled")
		return
	}
	// write "IsLocked"
	err = en.Append(0xa8, 0x49, 0x73, 0x4c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsLocked)
	if err != nil {
		err = msgp.WrapError(err, "IsLocked")
		return
	}
	// write "IsAdmin"
	err = en.Append(0xa7, 0x49, 0x73, 0x41, 0x64, 0x6d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsAdmin)
	if err != nil {
		err = msgp.WrapError(err, "IsAdmin")
		return
	}
	// write "PasswordNeverExpires"
	err = en.Append(0xb4, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x4e, 0x65, 0x76, 0x65, 0x72, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.PasswordNeverExpires)
	if err != nil {
		err = msgp.WrapError(err, "PasswordNeverExpires")
		return
	}
	// write "NoChangePassword"
	err = en.Append(0xb0, 0x4e, 0x6f, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.NoChangePassword)
	if err != nil {
		err = msgp.WrapError(err, "NoChangePassword")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *User) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "PasswordLastSet"
	o = append(o, 0x8d, 0xaf, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x4c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x74)
	o = msgp.AppendTime(o, z.PasswordLastSet)
	// string "LastLogon"
	o = append(o, 0xa9, 0x4c, 0x61, 0x73, 0x74, 0x4c, 0x6f, 0x67, 0x6f, 0x6e)
	o = msgp.AppendTime(o, z.LastLogon)
	// string "LastLogoff"
	o = append(o, 0xaa, 0x4c, 0x61, 0x73, 0x74, 0x4c, 0x6f, 0x67, 0x6f, 0x66, 0x66)
	o = msgp.AppendTime(o, z.LastLogoff)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "SID"
	o = append(o, 0xa3, 0x53, 0x49, 0x44)
	o = msgp.AppendString(o, z.SID)
	// string "FullName"
	o = append(o, 0xa8, 0x46, 0x75, 0x6c, 0x6c, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.FullName)
	// string "BadPasswordCount"
	o = append(o, 0xb0, 0x42, 0x61, 0x64, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.BadPasswordCount)
	// string "NumberOfLogins"
	o = append(o, 0xae, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f, 0x66, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x73)
	o = msgp.AppendInt(o, z.NumberOfLogins)
	// string "IsEnabled"
	o = append(o, 0xa9, 0x49, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsEnabled)
	// string "IsLocked"
	o = append(o, 0xa8, 0x49, 0x73, 0x4c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsLocked)
	// string "IsAdmin"
	o = append(o, 0xa7, 0x49, 0x73, 0x41, 0x64, 0x6d, 0x69, 0x6e)
	o = msgp.AppendBool(o, z.IsAdmin)
	// string "PasswordNeverExpires"
	o = append(o, 0xb4, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x4e, 0x65, 0x76, 0x65, 0x72, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73)
	o = msgp.AppendBool(o, z.PasswordNeverExpires)
	// string "NoChangePassword"
	o = append(o, 0xb0, 0x4e, 0x6f, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendBool(o, z.NoChangePassword)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *User) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PasswordLastSet":
			z.PasswordLastSet, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PasswordLastSet")
				return
			}
		case "LastLogon":
			z.LastLogon, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastLogon")
				return
			}
		case "LastLogoff":
			z.LastLogoff, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastLogoff")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SID":
			z.SID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SID")
				return
			}
		case "FullName":
			z.FullName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FullName")
				return
			}
		case "BadPasswordCount":
			z.BadPasswordCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BadPasswordCount")
				return
			}
		case "NumberOfLogins":
			z.NumberOfLogins, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumberOfLogins")
				return
			}
		case "IsEnabled":
			z.IsEnabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsEnabled")
				return
			}
		case "IsLocked":
			z.IsLocked, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsLocked")
				return
			}
		case "IsAdmin":
			z.IsAdmin, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsAdmin")
				return
			}
		case "PasswordNeverExpires":
			z.PasswordNeverExpires, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PasswordNeverExpires")
				return
			}
		case "NoChangePassword":
			z.NoChangePassword, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NoChangePassword")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *User) Msgsize() (s int) {
	s = 1 + 16 + msgp.TimeSize + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 5 + msgp.StringPrefixSize + len(z.Name) + 4 + msgp.StringPrefixSize + len(z.SID) + 9 + msgp.StringPrefixSize + len(z.FullName) + 17 + msgp.IntSize + 15 + msgp.IntSize + 10 + msgp.BoolSize + 9 + msgp.BoolSize + 8 + msgp.BoolSize + 21 + msgp.BoolSize + 17 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Users) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Users, zb0002)
	}
	for zb0001 := range *z {
		err = (*z)[zb0001].DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Users) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		err = z[zb0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Users) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0003 := range z {
		o, err = z[zb0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Users) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Users, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Users) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		s += z[zb0003].Msgsize()
	}
	return
}
