// Code generated by "enumer -type=TLSmode,AuthMode,LDAPScope,LDAPError,LDAPOption -json -output ldap_enums.go"; DO NOT EDIT.

package collect

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _TLSmodeName = "TLSStartTLSNoTLS"

var _TLSmodeIndex = [...]uint8{0, 3, 11, 16}

const _TLSmodeLowerName = "tlsstarttlsnotls"

func (i TLSmode) String() string {
	if i >= TLSmode(len(_TLSmodeIndex)-1) {
		return fmt.Sprintf("TLSmode(%d)", i)
	}
	return _TLSmodeName[_TLSmodeIndex[i]:_TLSmodeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TLSmodeNoOp() {
	var x [1]struct{}
	_ = x[TLS-(0)]
	_ = x[StartTLS-(1)]
	_ = x[NoTLS-(2)]
}

var _TLSmodeValues = []TLSmode{TLS, StartTLS, NoTLS}

var _TLSmodeNameToValueMap = map[string]TLSmode{
	_TLSmodeName[0:3]:        TLS,
	_TLSmodeLowerName[0:3]:   TLS,
	_TLSmodeName[3:11]:       StartTLS,
	_TLSmodeLowerName[3:11]:  StartTLS,
	_TLSmodeName[11:16]:      NoTLS,
	_TLSmodeLowerName[11:16]: NoTLS,
}

var _TLSmodeNames = []string{
	_TLSmodeName[0:3],
	_TLSmodeName[3:11],
	_TLSmodeName[11:16],
}

// TLSmodeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TLSmodeString(s string) (TLSmode, error) {
	if val, ok := _TLSmodeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TLSmodeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to TLSmode values", s)
}

// TLSmodeValues returns all values of the enum
func TLSmodeValues() []TLSmode {
	return _TLSmodeValues
}

// TLSmodeStrings returns a slice of all String values of the enum
func TLSmodeStrings() []string {
	strs := make([]string, len(_TLSmodeNames))
	copy(strs, _TLSmodeNames)
	return strs
}

// IsATLSmode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i TLSmode) IsATLSmode() bool {
	for _, v := range _TLSmodeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for TLSmode
func (i TLSmode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for TLSmode
func (i *TLSmode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("TLSmode should be a string, got %s", data)
	}

	var err error
	*i, err = TLSmodeString(s)
	return err
}

const _AuthModeName = "AnonymousBasicDigestKerberosCacheNTLMNTLMPTHNegotiate"

var _AuthModeIndex = [...]uint8{0, 9, 14, 20, 33, 37, 44, 53}

const _AuthModeLowerName = "anonymousbasicdigestkerberoscachentlmntlmpthnegotiate"

func (i AuthMode) String() string {
	if i >= AuthMode(len(_AuthModeIndex)-1) {
		return fmt.Sprintf("AuthMode(%d)", i)
	}
	return _AuthModeName[_AuthModeIndex[i]:_AuthModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _AuthModeNoOp() {
	var x [1]struct{}
	_ = x[Anonymous-(0)]
	_ = x[Basic-(1)]
	_ = x[Digest-(2)]
	_ = x[KerberosCache-(3)]
	_ = x[NTLM-(4)]
	_ = x[NTLMPTH-(5)]
	_ = x[Negotiate-(6)]
}

var _AuthModeValues = []AuthMode{Anonymous, Basic, Digest, KerberosCache, NTLM, NTLMPTH, Negotiate}

var _AuthModeNameToValueMap = map[string]AuthMode{
	_AuthModeName[0:9]:        Anonymous,
	_AuthModeLowerName[0:9]:   Anonymous,
	_AuthModeName[9:14]:       Basic,
	_AuthModeLowerName[9:14]:  Basic,
	_AuthModeName[14:20]:      Digest,
	_AuthModeLowerName[14:20]: Digest,
	_AuthModeName[20:33]:      KerberosCache,
	_AuthModeLowerName[20:33]: KerberosCache,
	_AuthModeName[33:37]:      NTLM,
	_AuthModeLowerName[33:37]: NTLM,
	_AuthModeName[37:44]:      NTLMPTH,
	_AuthModeLowerName[37:44]: NTLMPTH,
	_AuthModeName[44:53]:      Negotiate,
	_AuthModeLowerName[44:53]: Negotiate,
}

var _AuthModeNames = []string{
	_AuthModeName[0:9],
	_AuthModeName[9:14],
	_AuthModeName[14:20],
	_AuthModeName[20:33],
	_AuthModeName[33:37],
	_AuthModeName[37:44],
	_AuthModeName[44:53],
}

// AuthModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func AuthModeString(s string) (AuthMode, error) {
	if val, ok := _AuthModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _AuthModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to AuthMode values", s)
}

// AuthModeValues returns all values of the enum
func AuthModeValues() []AuthMode {
	return _AuthModeValues
}

// AuthModeStrings returns a slice of all String values of the enum
func AuthModeStrings() []string {
	strs := make([]string, len(_AuthModeNames))
	copy(strs, _AuthModeNames)
	return strs
}

// IsAAuthMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i AuthMode) IsAAuthMode() bool {
	for _, v := range _AuthModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for AuthMode
func (i AuthMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for AuthMode
func (i *AuthMode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("AuthMode should be a string, got %s", data)
	}

	var err error
	*i, err = AuthModeString(s)
	return err
}

const _LDAPScopeName = "LDAP_SCOPE_BASELDAP_SCOPE_ONELEVELLDAP_SCOPE_SUBTREE"

var _LDAPScopeIndex = [...]uint8{0, 15, 34, 52}

const _LDAPScopeLowerName = "ldap_scope_baseldap_scope_onelevelldap_scope_subtree"

func (i LDAPScope) String() string {
	if i >= LDAPScope(len(_LDAPScopeIndex)-1) {
		return fmt.Sprintf("LDAPScope(%d)", i)
	}
	return _LDAPScopeName[_LDAPScopeIndex[i]:_LDAPScopeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LDAPScopeNoOp() {
	var x [1]struct{}
	_ = x[LDAP_SCOPE_BASE-(0)]
	_ = x[LDAP_SCOPE_ONELEVEL-(1)]
	_ = x[LDAP_SCOPE_SUBTREE-(2)]
}

var _LDAPScopeValues = []LDAPScope{LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, LDAP_SCOPE_SUBTREE}

var _LDAPScopeNameToValueMap = map[string]LDAPScope{
	_LDAPScopeName[0:15]:       LDAP_SCOPE_BASE,
	_LDAPScopeLowerName[0:15]:  LDAP_SCOPE_BASE,
	_LDAPScopeName[15:34]:      LDAP_SCOPE_ONELEVEL,
	_LDAPScopeLowerName[15:34]: LDAP_SCOPE_ONELEVEL,
	_LDAPScopeName[34:52]:      LDAP_SCOPE_SUBTREE,
	_LDAPScopeLowerName[34:52]: LDAP_SCOPE_SUBTREE,
}

var _LDAPScopeNames = []string{
	_LDAPScopeName[0:15],
	_LDAPScopeName[15:34],
	_LDAPScopeName[34:52],
}

// LDAPScopeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LDAPScopeString(s string) (LDAPScope, error) {
	if val, ok := _LDAPScopeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LDAPScopeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LDAPScope values", s)
}

// LDAPScopeValues returns all values of the enum
func LDAPScopeValues() []LDAPScope {
	return _LDAPScopeValues
}

// LDAPScopeStrings returns a slice of all String values of the enum
func LDAPScopeStrings() []string {
	strs := make([]string, len(_LDAPScopeNames))
	copy(strs, _LDAPScopeNames)
	return strs
}

// IsALDAPScope returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LDAPScope) IsALDAPScope() bool {
	for _, v := range _LDAPScopeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for LDAPScope
func (i LDAPScope) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LDAPScope
func (i *LDAPScope) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LDAPScope should be a string, got %s", data)
	}

	var err error
	*i, err = LDAPScopeString(s)
	return err
}

const (
	_LDAPErrorName_0      = "LDAP_SUCCESSLDAP_OPERATIONS_ERRORLDAP_PROTOCOL_ERRORLDAP_TIMELIMIT_EXCEEDEDLDAP_SIZELIMIT_EXCEEDEDLDAP_COMPARE_FALSELDAP_COMPARE_TRUELDAP_AUTH_METHOD_NOT_SUPPORTEDLDAP_STRONG_AUTH_REQUIREDLDAP_PARTIAL_RESULTSLDAP_REFERRALLDAP_ADMIN_LIMIT_EXCEEDEDLDAP_UNAVAILABLE_CRITICAL_EXTENSIONLDAP_CONFIDENTIALITY_REQUIRED"
	_LDAPErrorLowerName_0 = "ldap_successldap_operations_errorldap_protocol_errorldap_timelimit_exceededldap_sizelimit_exceededldap_compare_falseldap_compare_trueldap_auth_method_not_supportedldap_strong_auth_requiredldap_partial_resultsldap_referralldap_admin_limit_exceededldap_unavailable_critical_extensionldap_confidentiality_required"
	_LDAPErrorName_1      = "LDAP_NO_SUCH_ATTRIBUTELDAP_UNDEFINED_TYPELDAP_INAPPROPRIATE_MATCHINGLDAP_CONSTRAINT_VIOLATIONLDAP_ATTRIBUTE_OR_VALUE_EXISTSLDAP_INVALID_SYNTAX"
	_LDAPErrorLowerName_1 = "ldap_no_such_attributeldap_undefined_typeldap_inappropriate_matchingldap_constraint_violationldap_attribute_or_value_existsldap_invalid_syntax"
	_LDAPErrorName_2      = "LDAP_NO_SUCH_OBJECTLDAP_ALIAS_PROBLEMLDAP_INVALID_DN_SYNTAXLDAP_IS_LEAFLDAP_ALIAS_DEREF_PROBLEM"
	_LDAPErrorLowerName_2 = "ldap_no_such_objectldap_alias_problemldap_invalid_dn_syntaxldap_is_leafldap_alias_deref_problem"
	_LDAPErrorName_3      = "LDAP_INAPPROPRIATE_AUTHLDAP_INVALID_CREDENTIALSLDAP_INSUFFICIENT_RIGHTSLDAP_BUSYLDAP_UNAVAILABLELDAP_UNWILLING_TO_PERFORMLDAP_LOOP_DETECT"
	_LDAPErrorLowerName_3 = "ldap_inappropriate_authldap_invalid_credentialsldap_insufficient_rightsldap_busyldap_unavailableldap_unwilling_to_performldap_loop_detect"
	_LDAPErrorName_4      = "LDAP_NAMING_VIOLATIONLDAP_OBJECT_CLASS_VIOLATIONLDAP_NOT_ALLOWED_ON_NONLEAFLDAP_NOT_ALLOWED_ON_RDNLDAP_ALREADY_EXISTSLDAP_NO_OBJECT_CLASS_MODSLDAP_RESULTS_TOO_LARGELDAP_AFFECTS_MULTIPLE_DSAS"
	_LDAPErrorLowerName_4 = "ldap_naming_violationldap_object_class_violationldap_not_allowed_on_nonleafldap_not_allowed_on_rdnldap_already_existsldap_no_object_class_modsldap_results_too_largeldap_affects_multiple_dsas"
	_LDAPErrorName_5      = "LDAP_VIRTUAL_LIST_VIEW_ERROR"
	_LDAPErrorLowerName_5 = "ldap_virtual_list_view_error"
	_LDAPErrorName_6      = "LDAP_OTHERLDAP_SERVER_DOWNLDAP_LOCAL_ERRORLDAP_ENCODING_ERRORLDAP_DECODING_ERRORLDAP_TIMEOUTLDAP_AUTH_UNKNOWNLDAP_FILTER_ERRORLDAP_USER_CANCELLEDLDAP_PARAM_ERRORLDAP_NO_MEMORYLDAP_CONNECT_ERRORLDAP_NOT_SUPPORTEDLDAP_CONTROL_NOT_FOUNDLDAP_NO_RESULTS_RETURNEDLDAP_MORE_RESULTS_TO_RETURNLDAP_CLIENT_LOOPLDAP_REFERRAL_LIMIT_EXCEEDED"
	_LDAPErrorLowerName_6 = "ldap_otherldap_server_downldap_local_errorldap_encoding_errorldap_decoding_errorldap_timeoutldap_auth_unknownldap_filter_errorldap_user_cancelledldap_param_errorldap_no_memoryldap_connect_errorldap_not_supportedldap_control_not_foundldap_no_results_returnedldap_more_results_to_returnldap_client_loopldap_referral_limit_exceeded"
)

var (
	_LDAPErrorIndex_0 = [...]uint16{0, 12, 33, 52, 75, 98, 116, 133, 163, 188, 208, 221, 246, 281, 310}
	_LDAPErrorIndex_1 = [...]uint8{0, 22, 41, 68, 93, 123, 142}
	_LDAPErrorIndex_2 = [...]uint8{0, 19, 37, 59, 71, 95}
	_LDAPErrorIndex_3 = [...]uint8{0, 23, 47, 71, 80, 96, 121, 137}
	_LDAPErrorIndex_4 = [...]uint8{0, 21, 48, 75, 98, 117, 142, 164, 190}
	_LDAPErrorIndex_5 = [...]uint8{0, 28}
	_LDAPErrorIndex_6 = [...]uint16{0, 10, 26, 42, 61, 80, 92, 109, 126, 145, 161, 175, 193, 211, 233, 257, 284, 300, 328}
)

func (i LDAPError) String() string {
	switch {
	case 0 <= i && i <= 13:
		return _LDAPErrorName_0[_LDAPErrorIndex_0[i]:_LDAPErrorIndex_0[i+1]]
	case 16 <= i && i <= 21:
		i -= 16
		return _LDAPErrorName_1[_LDAPErrorIndex_1[i]:_LDAPErrorIndex_1[i+1]]
	case 32 <= i && i <= 36:
		i -= 32
		return _LDAPErrorName_2[_LDAPErrorIndex_2[i]:_LDAPErrorIndex_2[i+1]]
	case 48 <= i && i <= 54:
		i -= 48
		return _LDAPErrorName_3[_LDAPErrorIndex_3[i]:_LDAPErrorIndex_3[i+1]]
	case 64 <= i && i <= 71:
		i -= 64
		return _LDAPErrorName_4[_LDAPErrorIndex_4[i]:_LDAPErrorIndex_4[i+1]]
	case i == 76:
		return _LDAPErrorName_5
	case 80 <= i && i <= 97:
		i -= 80
		return _LDAPErrorName_6[_LDAPErrorIndex_6[i]:_LDAPErrorIndex_6[i+1]]
	default:
		return fmt.Sprintf("LDAPError(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LDAPErrorNoOp() {
	var x [1]struct{}
	_ = x[LDAP_SUCCESS-(0)]
	_ = x[LDAP_OPERATIONS_ERROR-(1)]
	_ = x[LDAP_PROTOCOL_ERROR-(2)]
	_ = x[LDAP_TIMELIMIT_EXCEEDED-(3)]
	_ = x[LDAP_SIZELIMIT_EXCEEDED-(4)]
	_ = x[LDAP_COMPARE_FALSE-(5)]
	_ = x[LDAP_COMPARE_TRUE-(6)]
	_ = x[LDAP_AUTH_METHOD_NOT_SUPPORTED-(7)]
	_ = x[LDAP_STRONG_AUTH_REQUIRED-(8)]
	_ = x[LDAP_PARTIAL_RESULTS-(9)]
	_ = x[LDAP_REFERRAL-(10)]
	_ = x[LDAP_ADMIN_LIMIT_EXCEEDED-(11)]
	_ = x[LDAP_UNAVAILABLE_CRITICAL_EXTENSION-(12)]
	_ = x[LDAP_CONFIDENTIALITY_REQUIRED-(13)]
	_ = x[LDAP_NO_SUCH_ATTRIBUTE-(16)]
	_ = x[LDAP_UNDEFINED_TYPE-(17)]
	_ = x[LDAP_INAPPROPRIATE_MATCHING-(18)]
	_ = x[LDAP_CONSTRAINT_VIOLATION-(19)]
	_ = x[LDAP_ATTRIBUTE_OR_VALUE_EXISTS-(20)]
	_ = x[LDAP_INVALID_SYNTAX-(21)]
	_ = x[LDAP_NO_SUCH_OBJECT-(32)]
	_ = x[LDAP_ALIAS_PROBLEM-(33)]
	_ = x[LDAP_INVALID_DN_SYNTAX-(34)]
	_ = x[LDAP_IS_LEAF-(35)]
	_ = x[LDAP_ALIAS_DEREF_PROBLEM-(36)]
	_ = x[LDAP_INAPPROPRIATE_AUTH-(48)]
	_ = x[LDAP_INVALID_CREDENTIALS-(49)]
	_ = x[LDAP_INSUFFICIENT_RIGHTS-(50)]
	_ = x[LDAP_BUSY-(51)]
	_ = x[LDAP_UNAVAILABLE-(52)]
	_ = x[LDAP_UNWILLING_TO_PERFORM-(53)]
	_ = x[LDAP_LOOP_DETECT-(54)]
	_ = x[LDAP_NAMING_VIOLATION-(64)]
	_ = x[LDAP_OBJECT_CLASS_VIOLATION-(65)]
	_ = x[LDAP_NOT_ALLOWED_ON_NONLEAF-(66)]
	_ = x[LDAP_NOT_ALLOWED_ON_RDN-(67)]
	_ = x[LDAP_ALREADY_EXISTS-(68)]
	_ = x[LDAP_NO_OBJECT_CLASS_MODS-(69)]
	_ = x[LDAP_RESULTS_TOO_LARGE-(70)]
	_ = x[LDAP_AFFECTS_MULTIPLE_DSAS-(71)]
	_ = x[LDAP_VIRTUAL_LIST_VIEW_ERROR-(76)]
	_ = x[LDAP_OTHER-(80)]
	_ = x[LDAP_SERVER_DOWN-(81)]
	_ = x[LDAP_LOCAL_ERROR-(82)]
	_ = x[LDAP_ENCODING_ERROR-(83)]
	_ = x[LDAP_DECODING_ERROR-(84)]
	_ = x[LDAP_TIMEOUT-(85)]
	_ = x[LDAP_AUTH_UNKNOWN-(86)]
	_ = x[LDAP_FILTER_ERROR-(87)]
	_ = x[LDAP_USER_CANCELLED-(88)]
	_ = x[LDAP_PARAM_ERROR-(89)]
	_ = x[LDAP_NO_MEMORY-(90)]
	_ = x[LDAP_CONNECT_ERROR-(91)]
	_ = x[LDAP_NOT_SUPPORTED-(92)]
	_ = x[LDAP_CONTROL_NOT_FOUND-(93)]
	_ = x[LDAP_NO_RESULTS_RETURNED-(94)]
	_ = x[LDAP_MORE_RESULTS_TO_RETURN-(95)]
	_ = x[LDAP_CLIENT_LOOP-(96)]
	_ = x[LDAP_REFERRAL_LIMIT_EXCEEDED-(97)]
}

var _LDAPErrorValues = []LDAPError{LDAP_SUCCESS, LDAP_OPERATIONS_ERROR, LDAP_PROTOCOL_ERROR, LDAP_TIMELIMIT_EXCEEDED, LDAP_SIZELIMIT_EXCEEDED, LDAP_COMPARE_FALSE, LDAP_COMPARE_TRUE, LDAP_AUTH_METHOD_NOT_SUPPORTED, LDAP_STRONG_AUTH_REQUIRED, LDAP_PARTIAL_RESULTS, LDAP_REFERRAL, LDAP_ADMIN_LIMIT_EXCEEDED, LDAP_UNAVAILABLE_CRITICAL_EXTENSION, LDAP_CONFIDENTIALITY_REQUIRED, LDAP_NO_SUCH_ATTRIBUTE, LDAP_UNDEFINED_TYPE, LDAP_INAPPROPRIATE_MATCHING, LDAP_CONSTRAINT_VIOLATION, LDAP_ATTRIBUTE_OR_VALUE_EXISTS, LDAP_INVALID_SYNTAX, LDAP_NO_SUCH_OBJECT, LDAP_ALIAS_PROBLEM, LDAP_INVALID_DN_SYNTAX, LDAP_IS_LEAF, LDAP_ALIAS_DEREF_PROBLEM, LDAP_INAPPROPRIATE_AUTH, LDAP_INVALID_CREDENTIALS, LDAP_INSUFFICIENT_RIGHTS, LDAP_BUSY, LDAP_UNAVAILABLE, LDAP_UNWILLING_TO_PERFORM, LDAP_LOOP_DETECT, LDAP_NAMING_VIOLATION, LDAP_OBJECT_CLASS_VIOLATION, LDAP_NOT_ALLOWED_ON_NONLEAF, LDAP_NOT_ALLOWED_ON_RDN, LDAP_ALREADY_EXISTS, LDAP_NO_OBJECT_CLASS_MODS, LDAP_RESULTS_TOO_LARGE, LDAP_AFFECTS_MULTIPLE_DSAS, LDAP_VIRTUAL_LIST_VIEW_ERROR, LDAP_OTHER, LDAP_SERVER_DOWN, LDAP_LOCAL_ERROR, LDAP_ENCODING_ERROR, LDAP_DECODING_ERROR, LDAP_TIMEOUT, LDAP_AUTH_UNKNOWN, LDAP_FILTER_ERROR, LDAP_USER_CANCELLED, LDAP_PARAM_ERROR, LDAP_NO_MEMORY, LDAP_CONNECT_ERROR, LDAP_NOT_SUPPORTED, LDAP_CONTROL_NOT_FOUND, LDAP_NO_RESULTS_RETURNED, LDAP_MORE_RESULTS_TO_RETURN, LDAP_CLIENT_LOOP, LDAP_REFERRAL_LIMIT_EXCEEDED}

var _LDAPErrorNameToValueMap = map[string]LDAPError{
	_LDAPErrorName_0[0:12]:         LDAP_SUCCESS,
	_LDAPErrorLowerName_0[0:12]:    LDAP_SUCCESS,
	_LDAPErrorName_0[12:33]:        LDAP_OPERATIONS_ERROR,
	_LDAPErrorLowerName_0[12:33]:   LDAP_OPERATIONS_ERROR,
	_LDAPErrorName_0[33:52]:        LDAP_PROTOCOL_ERROR,
	_LDAPErrorLowerName_0[33:52]:   LDAP_PROTOCOL_ERROR,
	_LDAPErrorName_0[52:75]:        LDAP_TIMELIMIT_EXCEEDED,
	_LDAPErrorLowerName_0[52:75]:   LDAP_TIMELIMIT_EXCEEDED,
	_LDAPErrorName_0[75:98]:        LDAP_SIZELIMIT_EXCEEDED,
	_LDAPErrorLowerName_0[75:98]:   LDAP_SIZELIMIT_EXCEEDED,
	_LDAPErrorName_0[98:116]:       LDAP_COMPARE_FALSE,
	_LDAPErrorLowerName_0[98:116]:  LDAP_COMPARE_FALSE,
	_LDAPErrorName_0[116:133]:      LDAP_COMPARE_TRUE,
	_LDAPErrorLowerName_0[116:133]: LDAP_COMPARE_TRUE,
	_LDAPErrorName_0[133:163]:      LDAP_AUTH_METHOD_NOT_SUPPORTED,
	_LDAPErrorLowerName_0[133:163]: LDAP_AUTH_METHOD_NOT_SUPPORTED,
	_LDAPErrorName_0[163:188]:      LDAP_STRONG_AUTH_REQUIRED,
	_LDAPErrorLowerName_0[163:188]: LDAP_STRONG_AUTH_REQUIRED,
	_LDAPErrorName_0[188:208]:      LDAP_PARTIAL_RESULTS,
	_LDAPErrorLowerName_0[188:208]: LDAP_PARTIAL_RESULTS,
	_LDAPErrorName_0[208:221]:      LDAP_REFERRAL,
	_LDAPErrorLowerName_0[208:221]: LDAP_REFERRAL,
	_LDAPErrorName_0[221:246]:      LDAP_ADMIN_LIMIT_EXCEEDED,
	_LDAPErrorLowerName_0[221:246]: LDAP_ADMIN_LIMIT_EXCEEDED,
	_LDAPErrorName_0[246:281]:      LDAP_UNAVAILABLE_CRITICAL_EXTENSION,
	_LDAPErrorLowerName_0[246:281]: LDAP_UNAVAILABLE_CRITICAL_EXTENSION,
	_LDAPErrorName_0[281:310]:      LDAP_CONFIDENTIALITY_REQUIRED,
	_LDAPErrorLowerName_0[281:310]: LDAP_CONFIDENTIALITY_REQUIRED,
	_LDAPErrorName_1[0:22]:         LDAP_NO_SUCH_ATTRIBUTE,
	_LDAPErrorLowerName_1[0:22]:    LDAP_NO_SUCH_ATTRIBUTE,
	_LDAPErrorName_1[22:41]:        LDAP_UNDEFINED_TYPE,
	_LDAPErrorLowerName_1[22:41]:   LDAP_UNDEFINED_TYPE,
	_LDAPErrorName_1[41:68]:        LDAP_INAPPROPRIATE_MATCHING,
	_LDAPErrorLowerName_1[41:68]:   LDAP_INAPPROPRIATE_MATCHING,
	_LDAPErrorName_1[68:93]:        LDAP_CONSTRAINT_VIOLATION,
	_LDAPErrorLowerName_1[68:93]:   LDAP_CONSTRAINT_VIOLATION,
	_LDAPErrorName_1[93:123]:       LDAP_ATTRIBUTE_OR_VALUE_EXISTS,
	_LDAPErrorLowerName_1[93:123]:  LDAP_ATTRIBUTE_OR_VALUE_EXISTS,
	_LDAPErrorName_1[123:142]:      LDAP_INVALID_SYNTAX,
	_LDAPErrorLowerName_1[123:142]: LDAP_INVALID_SYNTAX,
	_LDAPErrorName_2[0:19]:         LDAP_NO_SUCH_OBJECT,
	_LDAPErrorLowerName_2[0:19]:    LDAP_NO_SUCH_OBJECT,
	_LDAPErrorName_2[19:37]:        LDAP_ALIAS_PROBLEM,
	_LDAPErrorLowerName_2[19:37]:   LDAP_ALIAS_PROBLEM,
	_LDAPErrorName_2[37:59]:        LDAP_INVALID_DN_SYNTAX,
	_LDAPErrorLowerName_2[37:59]:   LDAP_INVALID_DN_SYNTAX,
	_LDAPErrorName_2[59:71]:        LDAP_IS_LEAF,
	_LDAPErrorLowerName_2[59:71]:   LDAP_IS_LEAF,
	_LDAPErrorName_2[71:95]:        LDAP_ALIAS_DEREF_PROBLEM,
	_LDAPErrorLowerName_2[71:95]:   LDAP_ALIAS_DEREF_PROBLEM,
	_LDAPErrorName_3[0:23]:         LDAP_INAPPROPRIATE_AUTH,
	_LDAPErrorLowerName_3[0:23]:    LDAP_INAPPROPRIATE_AUTH,
	_LDAPErrorName_3[23:47]:        LDAP_INVALID_CREDENTIALS,
	_LDAPErrorLowerName_3[23:47]:   LDAP_INVALID_CREDENTIALS,
	_LDAPErrorName_3[47:71]:        LDAP_INSUFFICIENT_RIGHTS,
	_LDAPErrorLowerName_3[47:71]:   LDAP_INSUFFICIENT_RIGHTS,
	_LDAPErrorName_3[71:80]:        LDAP_BUSY,
	_LDAPErrorLowerName_3[71:80]:   LDAP_BUSY,
	_LDAPErrorName_3[80:96]:        LDAP_UNAVAILABLE,
	_LDAPErrorLowerName_3[80:96]:   LDAP_UNAVAILABLE,
	_LDAPErrorName_3[96:121]:       LDAP_UNWILLING_TO_PERFORM,
	_LDAPErrorLowerName_3[96:121]:  LDAP_UNWILLING_TO_PERFORM,
	_LDAPErrorName_3[121:137]:      LDAP_LOOP_DETECT,
	_LDAPErrorLowerName_3[121:137]: LDAP_LOOP_DETECT,
	_LDAPErrorName_4[0:21]:         LDAP_NAMING_VIOLATION,
	_LDAPErrorLowerName_4[0:21]:    LDAP_NAMING_VIOLATION,
	_LDAPErrorName_4[21:48]:        LDAP_OBJECT_CLASS_VIOLATION,
	_LDAPErrorLowerName_4[21:48]:   LDAP_OBJECT_CLASS_VIOLATION,
	_LDAPErrorName_4[48:75]:        LDAP_NOT_ALLOWED_ON_NONLEAF,
	_LDAPErrorLowerName_4[48:75]:   LDAP_NOT_ALLOWED_ON_NONLEAF,
	_LDAPErrorName_4[75:98]:        LDAP_NOT_ALLOWED_ON_RDN,
	_LDAPErrorLowerName_4[75:98]:   LDAP_NOT_ALLOWED_ON_RDN,
	_LDAPErrorName_4[98:117]:       LDAP_ALREADY_EXISTS,
	_LDAPErrorLowerName_4[98:117]:  LDAP_ALREADY_EXISTS,
	_LDAPErrorName_4[117:142]:      LDAP_NO_OBJECT_CLASS_MODS,
	_LDAPErrorLowerName_4[117:142]: LDAP_NO_OBJECT_CLASS_MODS,
	_LDAPErrorName_4[142:164]:      LDAP_RESULTS_TOO_LARGE,
	_LDAPErrorLowerName_4[142:164]: LDAP_RESULTS_TOO_LARGE,
	_LDAPErrorName_4[164:190]:      LDAP_AFFECTS_MULTIPLE_DSAS,
	_LDAPErrorLowerName_4[164:190]: LDAP_AFFECTS_MULTIPLE_DSAS,
	_LDAPErrorName_5[0:28]:         LDAP_VIRTUAL_LIST_VIEW_ERROR,
	_LDAPErrorLowerName_5[0:28]:    LDAP_VIRTUAL_LIST_VIEW_ERROR,
	_LDAPErrorName_6[0:10]:         LDAP_OTHER,
	_LDAPErrorLowerName_6[0:10]:    LDAP_OTHER,
	_LDAPErrorName_6[10:26]:        LDAP_SERVER_DOWN,
	_LDAPErrorLowerName_6[10:26]:   LDAP_SERVER_DOWN,
	_LDAPErrorName_6[26:42]:        LDAP_LOCAL_ERROR,
	_LDAPErrorLowerName_6[26:42]:   LDAP_LOCAL_ERROR,
	_LDAPErrorName_6[42:61]:        LDAP_ENCODING_ERROR,
	_LDAPErrorLowerName_6[42:61]:   LDAP_ENCODING_ERROR,
	_LDAPErrorName_6[61:80]:        LDAP_DECODING_ERROR,
	_LDAPErrorLowerName_6[61:80]:   LDAP_DECODING_ERROR,
	_LDAPErrorName_6[80:92]:        LDAP_TIMEOUT,
	_LDAPErrorLowerName_6[80:92]:   LDAP_TIMEOUT,
	_LDAPErrorName_6[92:109]:       LDAP_AUTH_UNKNOWN,
	_LDAPErrorLowerName_6[92:109]:  LDAP_AUTH_UNKNOWN,
	_LDAPErrorName_6[109:126]:      LDAP_FILTER_ERROR,
	_LDAPErrorLowerName_6[109:126]: LDAP_FILTER_ERROR,
	_LDAPErrorName_6[126:145]:      LDAP_USER_CANCELLED,
	_LDAPErrorLowerName_6[126:145]: LDAP_USER_CANCELLED,
	_LDAPErrorName_6[145:161]:      LDAP_PARAM_ERROR,
	_LDAPErrorLowerName_6[145:161]: LDAP_PARAM_ERROR,
	_LDAPErrorName_6[161:175]:      LDAP_NO_MEMORY,
	_LDAPErrorLowerName_6[161:175]: LDAP_NO_MEMORY,
	_LDAPErrorName_6[175:193]:      LDAP_CONNECT_ERROR,
	_LDAPErrorLowerName_6[175:193]: LDAP_CONNECT_ERROR,
	_LDAPErrorName_6[193:211]:      LDAP_NOT_SUPPORTED,
	_LDAPErrorLowerName_6[193:211]: LDAP_NOT_SUPPORTED,
	_LDAPErrorName_6[211:233]:      LDAP_CONTROL_NOT_FOUND,
	_LDAPErrorLowerName_6[211:233]: LDAP_CONTROL_NOT_FOUND,
	_LDAPErrorName_6[233:257]:      LDAP_NO_RESULTS_RETURNED,
	_LDAPErrorLowerName_6[233:257]: LDAP_NO_RESULTS_RETURNED,
	_LDAPErrorName_6[257:284]:      LDAP_MORE_RESULTS_TO_RETURN,
	_LDAPErrorLowerName_6[257:284]: LDAP_MORE_RESULTS_TO_RETURN,
	_LDAPErrorName_6[284:300]:      LDAP_CLIENT_LOOP,
	_LDAPErrorLowerName_6[284:300]: LDAP_CLIENT_LOOP,
	_LDAPErrorName_6[300:328]:      LDAP_REFERRAL_LIMIT_EXCEEDED,
	_LDAPErrorLowerName_6[300:328]: LDAP_REFERRAL_LIMIT_EXCEEDED,
}

var _LDAPErrorNames = []string{
	_LDAPErrorName_0[0:12],
	_LDAPErrorName_0[12:33],
	_LDAPErrorName_0[33:52],
	_LDAPErrorName_0[52:75],
	_LDAPErrorName_0[75:98],
	_LDAPErrorName_0[98:116],
	_LDAPErrorName_0[116:133],
	_LDAPErrorName_0[133:163],
	_LDAPErrorName_0[163:188],
	_LDAPErrorName_0[188:208],
	_LDAPErrorName_0[208:221],
	_LDAPErrorName_0[221:246],
	_LDAPErrorName_0[246:281],
	_LDAPErrorName_0[281:310],
	_LDAPErrorName_1[0:22],
	_LDAPErrorName_1[22:41],
	_LDAPErrorName_1[41:68],
	_LDAPErrorName_1[68:93],
	_LDAPErrorName_1[93:123],
	_LDAPErrorName_1[123:142],
	_LDAPErrorName_2[0:19],
	_LDAPErrorName_2[19:37],
	_LDAPErrorName_2[37:59],
	_LDAPErrorName_2[59:71],
	_LDAPErrorName_2[71:95],
	_LDAPErrorName_3[0:23],
	_LDAPErrorName_3[23:47],
	_LDAPErrorName_3[47:71],
	_LDAPErrorName_3[71:80],
	_LDAPErrorName_3[80:96],
	_LDAPErrorName_3[96:121],
	_LDAPErrorName_3[121:137],
	_LDAPErrorName_4[0:21],
	_LDAPErrorName_4[21:48],
	_LDAPErrorName_4[48:75],
	_LDAPErrorName_4[75:98],
	_LDAPErrorName_4[98:117],
	_LDAPErrorName_4[117:142],
	_LDAPErrorName_4[142:164],
	_LDAPErrorName_4[164:190],
	_LDAPErrorName_5[0:28],
	_LDAPErrorName_6[0:10],
	_LDAPErrorName_6[10:26],
	_LDAPErrorName_6[26:42],
	_LDAPErrorName_6[42:61],
	_LDAPErrorName_6[61:80],
	_LDAPErrorName_6[80:92],
	_LDAPErrorName_6[92:109],
	_LDAPErrorName_6[109:126],
	_LDAPErrorName_6[126:145],
	_LDAPErrorName_6[145:161],
	_LDAPErrorName_6[161:175],
	_LDAPErrorName_6[175:193],
	_LDAPErrorName_6[193:211],
	_LDAPErrorName_6[211:233],
	_LDAPErrorName_6[233:257],
	_LDAPErrorName_6[257:284],
	_LDAPErrorName_6[284:300],
	_LDAPErrorName_6[300:328],
}

// LDAPErrorString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LDAPErrorString(s string) (LDAPError, error) {
	if val, ok := _LDAPErrorNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LDAPErrorNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LDAPError values", s)
}

// LDAPErrorValues returns all values of the enum
func LDAPErrorValues() []LDAPError {
	return _LDAPErrorValues
}

// LDAPErrorStrings returns a slice of all String values of the enum
func LDAPErrorStrings() []string {
	strs := make([]string, len(_LDAPErrorNames))
	copy(strs, _LDAPErrorNames)
	return strs
}

// IsALDAPError returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LDAPError) IsALDAPError() bool {
	for _, v := range _LDAPErrorValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for LDAPError
func (i LDAPError) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LDAPError
func (i *LDAPError) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LDAPError should be a string, got %s", data)
	}

	var err error
	*i, err = LDAPErrorString(s)
	return err
}

const _LDAPOptionName = "LDAP_OPT_SIZELIMITLDAP_OPT_TIMELIMITLDAP_OPT_REFERRALSLDAP_OPT_SSLLDAP_OPT_REFERRAL_HOP_LIMITLDAP_OPT_PROTOCOL_VERSIONLDAP_OPT_HOST_NAMELDAP_OPT_SERVER_ERRORLDAP_OPT_SERVER_EXT_ERRORLDAP_OPT_PING_KEEP_ALIVELDAP_OPT_PING_WAIT_TIMELDAP_OPT_PING_LIMITLDAP_OPT_HOST_REACHABLELDAP_OPT_PROMPT_CREDENTIALSLDAP_OPT_TCP_KEEPALIVELDAP_OPT_SEND_TIMEOUTLDAP_OPT_SCH_FLAGSLDAP_OPT_SOCKET_BIND_ADDRESSESLDAP_OPT_REFERRAL_CALLBACKLDAP_OPT_SERVER_CERTIFICATELDAP_OPT_SSPI_FLAGSLDAP_OPT_SSL_INFOLDAP_OPT_REF_DEREF_CONN_PER_MSGLDAP_OPT_SIGNLDAP_OPT_SASL_METHODLDAP_OPT_SECURITY_CONTEXTLDAP_OPT_ROOTDSE_CACHE"
const _LDAPOptionLowerName = "ldap_opt_sizelimitldap_opt_timelimitldap_opt_referralsldap_opt_sslldap_opt_referral_hop_limitldap_opt_protocol_versionldap_opt_host_nameldap_opt_server_errorldap_opt_server_ext_errorldap_opt_ping_keep_aliveldap_opt_ping_wait_timeldap_opt_ping_limitldap_opt_host_reachableldap_opt_prompt_credentialsldap_opt_tcp_keepaliveldap_opt_send_timeoutldap_opt_sch_flagsldap_opt_socket_bind_addressesldap_opt_referral_callbackldap_opt_server_certificateldap_opt_sspi_flagsldap_opt_ssl_infoldap_opt_ref_deref_conn_per_msgldap_opt_signldap_opt_sasl_methodldap_opt_security_contextldap_opt_rootdse_cache"

var _LDAPOptionMap = map[LDAPOption]string{
	3:   _LDAPOptionName[0:18],
	4:   _LDAPOptionName[18:36],
	8:   _LDAPOptionName[36:54],
	10:  _LDAPOptionName[54:66],
	16:  _LDAPOptionName[66:93],
	17:  _LDAPOptionName[93:118],
	48:  _LDAPOptionName[118:136],
	51:  _LDAPOptionName[136:157],
	52:  _LDAPOptionName[157:182],
	54:  _LDAPOptionName[182:206],
	55:  _LDAPOptionName[206:229],
	56:  _LDAPOptionName[229:248],
	62:  _LDAPOptionName[248:271],
	63:  _LDAPOptionName[271:298],
	64:  _LDAPOptionName[298:320],
	66:  _LDAPOptionName[320:341],
	67:  _LDAPOptionName[341:359],
	68:  _LDAPOptionName[359:389],
	112: _LDAPOptionName[389:415],
	129: _LDAPOptionName[415:442],
	146: _LDAPOptionName[442:461],
	147: _LDAPOptionName[461:478],
	148: _LDAPOptionName[478:509],
	149: _LDAPOptionName[509:522],
	151: _LDAPOptionName[522:542],
	153: _LDAPOptionName[542:567],
	154: _LDAPOptionName[567:589],
}

func (i LDAPOption) String() string {
	if str, ok := _LDAPOptionMap[i]; ok {
		return str
	}
	return fmt.Sprintf("LDAPOption(%d)", i)
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LDAPOptionNoOp() {
	var x [1]struct{}
	_ = x[LDAP_OPT_SIZELIMIT-(3)]
	_ = x[LDAP_OPT_TIMELIMIT-(4)]
	_ = x[LDAP_OPT_REFERRALS-(8)]
	_ = x[LDAP_OPT_SSL-(10)]
	_ = x[LDAP_OPT_REFERRAL_HOP_LIMIT-(16)]
	_ = x[LDAP_OPT_PROTOCOL_VERSION-(17)]
	_ = x[LDAP_OPT_HOST_NAME-(48)]
	_ = x[LDAP_OPT_SERVER_ERROR-(51)]
	_ = x[LDAP_OPT_SERVER_EXT_ERROR-(52)]
	_ = x[LDAP_OPT_PING_KEEP_ALIVE-(54)]
	_ = x[LDAP_OPT_PING_WAIT_TIME-(55)]
	_ = x[LDAP_OPT_PING_LIMIT-(56)]
	_ = x[LDAP_OPT_HOST_REACHABLE-(62)]
	_ = x[LDAP_OPT_PROMPT_CREDENTIALS-(63)]
	_ = x[LDAP_OPT_TCP_KEEPALIVE-(64)]
	_ = x[LDAP_OPT_SEND_TIMEOUT-(66)]
	_ = x[LDAP_OPT_SCH_FLAGS-(67)]
	_ = x[LDAP_OPT_SOCKET_BIND_ADDRESSES-(68)]
	_ = x[LDAP_OPT_REFERRAL_CALLBACK-(112)]
	_ = x[LDAP_OPT_SERVER_CERTIFICATE-(129)]
	_ = x[LDAP_OPT_SSPI_FLAGS-(146)]
	_ = x[LDAP_OPT_SSL_INFO-(147)]
	_ = x[LDAP_OPT_REF_DEREF_CONN_PER_MSG-(148)]
	_ = x[LDAP_OPT_SIGN-(149)]
	_ = x[LDAP_OPT_SASL_METHOD-(151)]
	_ = x[LDAP_OPT_SECURITY_CONTEXT-(153)]
	_ = x[LDAP_OPT_ROOTDSE_CACHE-(154)]
}

var _LDAPOptionValues = []LDAPOption{LDAP_OPT_SIZELIMIT, LDAP_OPT_TIMELIMIT, LDAP_OPT_REFERRALS, LDAP_OPT_SSL, LDAP_OPT_REFERRAL_HOP_LIMIT, LDAP_OPT_PROTOCOL_VERSION, LDAP_OPT_HOST_NAME, LDAP_OPT_SERVER_ERROR, LDAP_OPT_SERVER_EXT_ERROR, LDAP_OPT_PING_KEEP_ALIVE, LDAP_OPT_PING_WAIT_TIME, LDAP_OPT_PING_LIMIT, LDAP_OPT_HOST_REACHABLE, LDAP_OPT_PROMPT_CREDENTIALS, LDAP_OPT_TCP_KEEPALIVE, LDAP_OPT_SEND_TIMEOUT, LDAP_OPT_SCH_FLAGS, LDAP_OPT_SOCKET_BIND_ADDRESSES, LDAP_OPT_REFERRAL_CALLBACK, LDAP_OPT_SERVER_CERTIFICATE, LDAP_OPT_SSPI_FLAGS, LDAP_OPT_SSL_INFO, LDAP_OPT_REF_DEREF_CONN_PER_MSG, LDAP_OPT_SIGN, LDAP_OPT_SASL_METHOD, LDAP_OPT_SECURITY_CONTEXT, LDAP_OPT_ROOTDSE_CACHE}

var _LDAPOptionNameToValueMap = map[string]LDAPOption{
	_LDAPOptionName[0:18]:         LDAP_OPT_SIZELIMIT,
	_LDAPOptionLowerName[0:18]:    LDAP_OPT_SIZELIMIT,
	_LDAPOptionName[18:36]:        LDAP_OPT_TIMELIMIT,
	_LDAPOptionLowerName[18:36]:   LDAP_OPT_TIMELIMIT,
	_LDAPOptionName[36:54]:        LDAP_OPT_REFERRALS,
	_LDAPOptionLowerName[36:54]:   LDAP_OPT_REFERRALS,
	_LDAPOptionName[54:66]:        LDAP_OPT_SSL,
	_LDAPOptionLowerName[54:66]:   LDAP_OPT_SSL,
	_LDAPOptionName[66:93]:        LDAP_OPT_REFERRAL_HOP_LIMIT,
	_LDAPOptionLowerName[66:93]:   LDAP_OPT_REFERRAL_HOP_LIMIT,
	_LDAPOptionName[93:118]:       LDAP_OPT_PROTOCOL_VERSION,
	_LDAPOptionLowerName[93:118]:  LDAP_OPT_PROTOCOL_VERSION,
	_LDAPOptionName[118:136]:      LDAP_OPT_HOST_NAME,
	_LDAPOptionLowerName[118:136]: LDAP_OPT_HOST_NAME,
	_LDAPOptionName[136:157]:      LDAP_OPT_SERVER_ERROR,
	_LDAPOptionLowerName[136:157]: LDAP_OPT_SERVER_ERROR,
	_LDAPOptionName[157:182]:      LDAP_OPT_SERVER_EXT_ERROR,
	_LDAPOptionLowerName[157:182]: LDAP_OPT_SERVER_EXT_ERROR,
	_LDAPOptionName[182:206]:      LDAP_OPT_PING_KEEP_ALIVE,
	_LDAPOptionLowerName[182:206]: LDAP_OPT_PING_KEEP_ALIVE,
	_LDAPOptionName[206:229]:      LDAP_OPT_PING_WAIT_TIME,
	_LDAPOptionLowerName[206:229]: LDAP_OPT_PING_WAIT_TIME,
	_LDAPOptionName[229:248]:      LDAP_OPT_PING_LIMIT,
	_LDAPOptionLowerName[229:248]: LDAP_OPT_PING_LIMIT,
	_LDAPOptionName[248:271]:      LDAP_OPT_HOST_REACHABLE,
	_LDAPOptionLowerName[248:271]: LDAP_OPT_HOST_REACHABLE,
	_LDAPOptionName[271:298]:      LDAP_OPT_PROMPT_CREDENTIALS,
	_LDAPOptionLowerName[271:298]: LDAP_OPT_PROMPT_CREDENTIALS,
	_LDAPOptionName[298:320]:      LDAP_OPT_TCP_KEEPALIVE,
	_LDAPOptionLowerName[298:320]: LDAP_OPT_TCP_KEEPALIVE,
	_LDAPOptionName[320:341]:      LDAP_OPT_SEND_TIMEOUT,
	_LDAPOptionLowerName[320:341]: LDAP_OPT_SEND_TIMEOUT,
	_LDAPOptionName[341:359]:      LDAP_OPT_SCH_FLAGS,
	_LDAPOptionLowerName[341:359]: LDAP_OPT_SCH_FLAGS,
	_LDAPOptionName[359:389]:      LDAP_OPT_SOCKET_BIND_ADDRESSES,
	_LDAPOptionLowerName[359:389]: LDAP_OPT_SOCKET_BIND_ADDRESSES,
	_LDAPOptionName[389:415]:      LDAP_OPT_REFERRAL_CALLBACK,
	_LDAPOptionLowerName[389:415]: LDAP_OPT_REFERRAL_CALLBACK,
	_LDAPOptionName[415:442]:      LDAP_OPT_SERVER_CERTIFICATE,
	_LDAPOptionLowerName[415:442]: LDAP_OPT_SERVER_CERTIFICATE,
	_LDAPOptionName[442:461]:      LDAP_OPT_SSPI_FLAGS,
	_LDAPOptionLowerName[442:461]: LDAP_OPT_SSPI_FLAGS,
	_LDAPOptionName[461:478]:      LDAP_OPT_SSL_INFO,
	_LDAPOptionLowerName[461:478]: LDAP_OPT_SSL_INFO,
	_LDAPOptionName[478:509]:      LDAP_OPT_REF_DEREF_CONN_PER_MSG,
	_LDAPOptionLowerName[478:509]: LDAP_OPT_REF_DEREF_CONN_PER_MSG,
	_LDAPOptionName[509:522]:      LDAP_OPT_SIGN,
	_LDAPOptionLowerName[509:522]: LDAP_OPT_SIGN,
	_LDAPOptionName[522:542]:      LDAP_OPT_SASL_METHOD,
	_LDAPOptionLowerName[522:542]: LDAP_OPT_SASL_METHOD,
	_LDAPOptionName[542:567]:      LDAP_OPT_SECURITY_CONTEXT,
	_LDAPOptionLowerName[542:567]: LDAP_OPT_SECURITY_CONTEXT,
	_LDAPOptionName[567:589]:      LDAP_OPT_ROOTDSE_CACHE,
	_LDAPOptionLowerName[567:589]: LDAP_OPT_ROOTDSE_CACHE,
}

var _LDAPOptionNames = []string{
	_LDAPOptionName[0:18],
	_LDAPOptionName[18:36],
	_LDAPOptionName[36:54],
	_LDAPOptionName[54:66],
	_LDAPOptionName[66:93],
	_LDAPOptionName[93:118],
	_LDAPOptionName[118:136],
	_LDAPOptionName[136:157],
	_LDAPOptionName[157:182],
	_LDAPOptionName[182:206],
	_LDAPOptionName[206:229],
	_LDAPOptionName[229:248],
	_LDAPOptionName[248:271],
	_LDAPOptionName[271:298],
	_LDAPOptionName[298:320],
	_LDAPOptionName[320:341],
	_LDAPOptionName[341:359],
	_LDAPOptionName[359:389],
	_LDAPOptionName[389:415],
	_LDAPOptionName[415:442],
	_LDAPOptionName[442:461],
	_LDAPOptionName[461:478],
	_LDAPOptionName[478:509],
	_LDAPOptionName[509:522],
	_LDAPOptionName[522:542],
	_LDAPOptionName[542:567],
	_LDAPOptionName[567:589],
}

// LDAPOptionString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LDAPOptionString(s string) (LDAPOption, error) {
	if val, ok := _LDAPOptionNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LDAPOptionNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LDAPOption values", s)
}

// LDAPOptionValues returns all values of the enum
func LDAPOptionValues() []LDAPOption {
	return _LDAPOptionValues
}

// LDAPOptionStrings returns a slice of all String values of the enum
func LDAPOptionStrings() []string {
	strs := make([]string, len(_LDAPOptionNames))
	copy(strs, _LDAPOptionNames)
	return strs
}

// IsALDAPOption returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LDAPOption) IsALDAPOption() bool {
	_, ok := _LDAPOptionMap[i]
	return ok
}

// MarshalJSON implements the json.Marshaler interface for LDAPOption
func (i LDAPOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LDAPOption
func (i *LDAPOption) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LDAPOption should be a string, got %s", data)
	}

	var err error
	*i, err = LDAPOptionString(s)
	return err
}
